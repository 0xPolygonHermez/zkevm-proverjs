pragma circom 2.1.0;
pragma custom_templates;

include "<%- verifierNames[0] %>.verifier.circom";
include "<%- verifierNames[1] %>.verifier.circom";
include "verify_blob_outer.circom";

<% let starkInfo = starkInfoVerifiers[0]; %>
<% let starkInfo2 = starkInfoVerifiers[1]; %>

<% let batchPublics = starkInfo.nPublics - 4; -%>
<% let blobInnerPublics = starkInfo2.nPublics; -%>
<% let blobOuterPublics = 60; -%>

template Main() {

    var rootCRecursive1Batch[4] = [<%- vks[0].join(",") %>];
    var rootCRecursive2Batch[4] = [<%- vks[1].join(",") %>];

    signal input publics[<%- blobOuterPublics.nPublics %>];
    signal input rootC[4];

    signal input chainId;

    // Batch Proof Inputs
    signal input batch_publics[<%- batchPublics %>];

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
    signal input batch_root<%- s %>[4];
<%  } -%>

    signal input batch_evals[<%- starkInfo.evMap.length %>][3];

    signal input batch_s0_valsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.nConstants %>];
    signal input batch_s0_siblingsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
<%     if (starkInfo.mapSectionsN[`cm${s}_2ns`] > 0) { -%>
    signal input batch_s0_vals<%- s %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cm${s}_n`] %>];
    signal input batch_s0_siblings<%- s %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
<%     } -%>
<% } -%>

<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    signal input batch_s<%- s %>_root[4];
<% }                                                  -%>

<% for (let s=1; s< starkInfo.starkStruct.steps.length; s++) {   -%>
    signal input batch_s<%- s %>_vals[<%- starkInfo.starkStruct.nQueries %>][<%- (1 << parseInt(starkInfo.starkStruct.steps[s-1].nBits - starkInfo.starkStruct.steps[s].nBits))*3 %>];
    signal input batch_s<%- s %>_siblings[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[s].nBits %>][4];
<% }                                                  -%>

    signal input batch_finalPol[<%- 1 << parseInt(starkInfo.starkStruct.steps[starkInfo.starkStruct.steps.length-1].nBits) %>][3];

    signal input batch_isAggregatedCircuit;
    
    // Blob Inner Proof Inputs
    signal input blob_inner_publics[<%- blobInnerPublics %>];
 
<%  for (let s=1; s<=nStages + 1; ++s) { -%>
    signal input blob_inner_root<%- s %>[4];
<%  } -%>

    signal input blob_inner_evals[<%- starkInfo2.evMap.length %>][3];

    signal input blob_inner_s0_valsC[<%- starkInfo2.starkStruct.nQueries %>][<%- starkInfo2.nConstants %>];
    signal input blob_inner_s0_siblingsC[<%- starkInfo2.starkStruct.nQueries %>][<%- starkInfo2.starkStruct.steps[0].nBits %>][4];

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
<%     if (starkInfo2.mapSectionsN[`cm${s}_2ns`] > 0) { -%>
    signal input blob_inner_s0_vals<%- s %>[<%- starkInfo2.starkStruct.nQueries %>][<%- starkInfo2.mapSectionsN[`cm${s}_n`] %>];
    signal input blob_inner_s0_siblings<%- s %>[<%- starkInfo2.starkStruct.nQueries %>][<%- starkInfo2.starkStruct.steps[0].nBits %>][4];
<%     } -%>
<% } -%>
    
<% for (let s=1; s<starkInfo2.starkStruct.steps.length; s++) {   -%>
    signal input blob_inner_s<%- s %>_root[4];
<% }                                                  -%>

<% for (let s=1; s< starkInfo2.starkStruct.steps.length; s++) {   -%>
    signal input blob_inner_s<%- s %>_vals[<%- starkInfo2.starkStruct.nQueries %>][<%- (1 << parseInt(starkInfo2.starkStruct.steps[s-1].nBits - starkInfo2.starkStruct.steps[s].nBits))*3 %>];
    signal input blob_inner_s<%- s %>_siblings[<%- starkInfo2.starkStruct.nQueries %>][<%- starkInfo2.starkStruct.steps[s].nBits %>][4];
<% }                                                  -%>

    signal input blob_inner_finalPol[<%- 1 << parseInt(starkInfo2.starkStruct.steps[starkInfo2.starkStruct.steps.length-1].nBits) %>][3];

    signal isValidBlob;
    signal publicsBlobOuter[<%- blobOuterPublics.nPublics %>];
    (isValidBlob, publicsBlobOuter) <== VerifyBlobOuter()(batch_publics, blob_inner_publics, chainId);

    for(var i=0; i<<%- blobOuterPublics.nPublics %>; i++) {
        publics[i] === publicsBlobOuter[i];
    }

    component vBatch = StarkVerifier();

    for (var i=0; i< <%- batchPublics %>; i++) {
        vBatch.publics[i] <== batch_publics[i];
    }

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
    vBatch.root<%- s %> <== batch_root<%- s %>;
<% } -%>

    vBatch.evals <== batch_evals;

    vBatch.s0_valsC <== batch_s0_valsC;
    vBatch.s0_siblingsC <== batch_s0_siblingsC;

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
<%     if (starkInfo.mapSectionsN[`cm${s}_2ns`] > 0) { -%>
    vBatch.s0_vals<%- s %> <== batch_s0_vals<%- s %>;
    vBatch.s0_siblings<%- s %> <== batch_s0_siblings<%- s %>;
<%     } -%>
<% } -%>

<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    vBatch.s<%- s %>_root <== batch_s<%- s %>_root;
<% }                                                  -%>
<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    vBatch.s<%- s %>_vals <== batch_s<%- s %>_vals;
    vBatch.s<%- s %>_siblings <== batch_s<%- s %>_siblings;
<% }                                                  -%>
    vBatch.finalPol <== batch_finalPol;

    signal isOneBatch <== 1 - batch_isAggregatedCircuit;
    vBatch.rootC <== MultiMux1(4)([rootCRecursive2Batch, rootCRecursive1Batch], isOneBatch);
    
    vBatch.enable <== isValidBlob; // Check isValid public

    for (var i=0; i<4; i++) {
        vBatch.publics[<%- batchPublics %> + i] <== rootCRecursive2Batch[i];
    }

    component vBlob = StarkVerifier2();

    for (var i=0; i< <%- blobInnerPublics %>; i++) {
        vBlob.publics[i] <== blob_inner_publics[i];
    }

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
    vBlob.root<%- s %> <== blob_inner_root<%- s %>;
<% } -%>
   
    vBlob.evals <== blob_inner_evals;

    vBlob.s0_valsC <== blob_inner_s0_valsC;
    vBlob.s0_siblingsC <== blob_inner_s0_siblingsC;

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
<%     if (starkInfo2.mapSectionsN[`cm${s}_2ns`] > 0) { -%>
    vBlob.s0_vals<%- s %> <== blob_inner_s0_vals<%- s %>;
    vBlob.s0_siblings<%- s %> <== blob_inner_s0_siblings<%- s %>;
<%     } -%>
<% } -%>

<% for (let s=1; s<starkInfo2.starkStruct.steps.length; s++) {   -%>
    vBlob.s<%- s %>_root <== blob_inner_s<%- s %>_root;
<% }                                                  -%>
<% for (let s=1; s<starkInfo2.starkStruct.steps.length; s++) {   -%>
    vBlob.s<%- s %>_vals <== blob_inner_s<%- s %>_vals;
    vBlob.s<%- s %>_siblings <== blob_inner_s<%- s %>_siblings;
<% }                                                  -%>
    vBlob.finalPol <== blob_inner_finalPol;

}

component main {public [publics, rootC]}= Main();