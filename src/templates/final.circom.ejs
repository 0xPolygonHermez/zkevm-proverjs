pragma circom 2.1.0;

include "<%- verifierNames[0] %>.verifier.circom";
include "lessthangl.circom";
include "get_sha256_inputs.circom";

<% let starkInfo = starkInfoVerifiers[0]; -%>
template Main() {
    signal output publicsHash;

    signal input aggregatorAddr;

    signal input publics[<%- starkInfo.nPublics %>];

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
    signal input root<%- s %>;
<%  } -%>

    signal input evals[<%- starkInfo.evMap.length %>][3]; // Evaluations of the set polynomials at a challenge value z and gz

    signal input s0_valsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.nConstants %>];
    signal input s0_siblingsC[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[0].nBits) - 1)/Math.log2(arity))+1 %>][<%- arity %>];

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
<%     if (starkInfo.mapSectionsN[`cm${s}_2ns`] > 0) { -%>
    signal input s0_vals<%- s %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cm${s}_n`] %>];
    signal input s0_siblings<%- s %>[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[0].nBits) - 1)/Math.log2(arity))+1 %>][<%- arity %>];
<%     } -%>
<% } -%>

<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_root;
<% }                                                  -%>

<% for (let s=1; s< starkInfo.starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_vals[<%- starkInfo.starkStruct.nQueries %>][<%- (1 << parseInt(starkInfo.starkStruct.steps[s-1].nBits - starkInfo.starkStruct.steps[s].nBits))*3 %>];
    signal input s<%- s %>_siblings[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[s].nBits) -1) /Math.log2(arity)) +1 %>][<%- arity %>];
<% }                                                  -%>

    signal input finalPol[<%- 1 << parseInt(starkInfo.starkStruct.steps[starkInfo.starkStruct.steps.length-1].nBits) %>][3];


    component sv = StarkVerifier();
    sv.publics <== publics;
<%  for (let s=1; s<=nStages + 1; ++s) { -%>
    sv.root<%- s %> <== root<%- s %>;
<% } -%>

    sv.evals <== evals;

    sv.s0_valsC <== s0_valsC;
    sv.s0_siblingsC <== s0_siblingsC;

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
<%     if (starkInfo.mapSectionsN[`cm${s}_2ns`] > 0) { -%>
    sv.s0_vals<%- s %> <== s0_vals<%- s %>;
    sv.s0_siblings<%- s %> <== s0_siblings<%- s %>;
<%     } -%>
<% } -%>
 
<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    sv.s<%- s %>_root <== s<%- s %>_root;
<% }                                                  -%>
<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    sv.s<%- s %>_vals <== s<%- s %>_vals;
    sv.s<%- s %>_siblings <== s<%- s %>_siblings;
<% } -%>    

    sv.finalPol <== finalPol;

    signal oldStateRoot[8];
    signal newStateRoot[8];

<%  if(isEip4844) { -%>
    signal oldBlobStateRoot[8];
    signal newBlobStateRoot[8];
    (publicsHash, oldStateRoot, newStateRoot, oldBlobStateRoot, newBlobStateRoot) <== getSha256Inputs()(aggregatorAddr, publics);
    
    // Check that state roots are lower than GL
    for (var i = 0; i < 4; i++) {
        _<== LessThanGoldilocks()(oldStateRoot[2*i] + (1 << 32) * oldStateRoot[2*i + 1]);
        _<== LessThanGoldilocks()(newStateRoot[2*i] + (1 << 32) * newStateRoot[2*i + 1]);
        _<== LessThanGoldilocks()(oldBlobStateRoot[2*i] + (1 << 32) * oldBlobStateRoot[2*i + 1]);
        _<== LessThanGoldilocks()(newBlobStateRoot[2*i] + (1 << 32) * newBlobStateRoot[2*i + 1]);
    }
<%  } else { -%>
    (publicsHash, oldStateRoot, newStateRoot) <== getSha256Inputs()(aggregatorAddr, publics);

    // Check that state roots are lower than GL
    for (var i = 0; i < 4; i++) {
        _<== LessThanGoldilocks()(oldStateRoot[2*i] + (1 << 32) * oldStateRoot[2*i + 1]);
        _<== LessThanGoldilocks()(newStateRoot[2*i] + (1 << 32) * newStateRoot[2*i + 1]);
    }
<%  } -%>
}

component main = Main();