pragma circom 2.1.0;
pragma custom_templates;

include "iszero.circom";

template VerifyRecursive2() {
    var oldStateRootPos = <%- publics.oldStateRootPos %>;
    var oldBatchAccInputHashPos = <%- publics.oldBatchAccInputHashPos %>;
    var previousL1InfoTreeRootPos = <%- publics.previousL1InfoTreeRootPos %>;
    var previousL1InfoTreeIndexPos = <%- publics.previousL1InfoTreeIndexPos %>;
    var chainIdPos = <%- publics.chainIdPos %>;
    var forkIdPos = <%- publics.forkIdPos %>;
    var newStateRootPos = <%- publics.newStateRootPos %>;
    var newBatchAccInputHashPos = <%- publics.newBatchAccInputHashPos %>;
    var currentL1InfoTreeRootPos = <%- publics.currentL1InfoTreeRootPos %>;
    var currentL1InfoTreeIndexPos = <%- publics.currentL1InfoTreeIndexPos %>;
    var newLocalExitRootPos = <%- publics.newLocalExitRootPos %>;
    var newLastTimestampPos = <%- publics.newLastTimestampPos %>;

    signal input a_publics[<%- publics.nPublics %>];
    signal input b_publics[<%- publics.nPublics %>];

    signal input a_isAggregatedCircuit;
    signal input b_isAggregatedCircuit;

    signal output publics[<%- publics.nPublics %>];
    signal output a_isOneBatch;
    signal output b_isOneBatch;

    // Check recursive 2 publics

    for (var i=0; i<8; i++) {
        a_publics[newStateRootPos + i] === b_publics[oldStateRootPos + i]; // Check State Root
        publics[oldStateRootPos + i] <== a_publics[oldStateRootPos + i]; // Old State Root
        publics[newStateRootPos + i] <== b_publics[newStateRootPos + i]; // New State Root

        a_publics[newBatchAccInputHashPos + i] === b_publics[oldBatchAccInputHashPos + i]; // Check accumulated input hash
        publics[oldBatchAccInputHashPos + i] <== a_publics[oldBatchAccInputHashPos + i]; // Old accumulated input hash
        publics[newBatchAccInputHashPos + i] <== b_publics[newBatchAccInputHashPos + i]; // New accumulated input hash

        a_publics[currentL1InfoTreeRootPos + i] === b_publics[previousL1InfoTreeRootPos + i]; // Check L1 Info Tree Root
        publics[previousL1InfoTreeRootPos + i] <== a_publics[previousL1InfoTreeRootPos + i]; // Old L1 Info Tree Root
        publics[currentL1InfoTreeRootPos + i] <== b_publics[currentL1InfoTreeRootPos + i]; // New L1 Info Tree Root

        publics[newLocalExitRootPos+i] <== b_publics[newLocalExitRootPos+i]; // Local exit root
    }

    a_publics[chainIdPos] === b_publics[chainIdPos]; // Check that chain ID matches between chains
    publics[chainIdPos] <== a_publics[chainIdPos]; // Chain ID

    a_publics[forkIdPos] === b_publics[forkIdPos]; // Check that fork ID matches between chains
    publics[forkIdPos] <== a_publics[forkIdPos]; // Fork ID

    a_publics[currentL1InfoTreeIndexPos] === b_publics[previousL1InfoTreeIndexPos]; // Check L1 Info Tree Index
    publics[previousL1InfoTreeIndexPos] <== a_publics[previousL1InfoTreeIndexPos]; // Old L1 Info Tree Index
    publics[currentL1InfoTreeIndexPos] <== b_publics[currentL1InfoTreeIndexPos]; // New L1 Info Tree Index

    publics[newLastTimestampPos] <== b_publics[newLastTimestampPos]; // Last timestamp

    a_isOneBatch <== IsZero()(a_isAggregatedCircuit);
    b_isOneBatch <== IsZero()(b_isAggregatedCircuit);
}

<% if(isTest) { -%>
    component main = VerifyRecursive2();
<% } -%>
