pragma circom 2.1.0;
pragma custom_templates;

include "c12a.verifier.circom";

template Main() {

    signal input publics[44];
    signal input rootC[4];

    signal input root1[4];
    signal input root2[4];
    signal input root3[4];
    signal input root4[4];
    signal input evals[<%- starkInfo.evMap.length %>][3]; // Evaluations of the set polynomials at a challenge value z and gz

    // Leaves values of the merkle tree used to check all the queries
    signal input s0_vals1[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm1_n %>];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    signal input s0_vals2[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm2_n %>];
<% } -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    signal input s0_vals3[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm3_n %>];
<% } -%>
    signal input s0_vals4[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm4_n %>];
    signal input s0_valsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.nConstants %>];
    signal input s0_siblings1[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    signal input s0_siblings2[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
<% } -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    signal input s0_siblings3[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
<% } -%>
    signal input s0_siblings4[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
    signal input s0_siblingsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];

<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_root[4];
<% }                                                  -%>

<% for (let s=1; s< starkInfo.starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_vals[<%- starkInfo.starkStruct.nQueries %>][<%- (1 << parseInt(starkInfo.starkStruct.steps[s-1].nBits - starkInfo.starkStruct.steps[s].nBits))*3 %>];
    signal input s<%- s %>_siblings[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[s].nBits %>][4];
<% }                                                  -%>

    signal input finalPol[<%- 1 << parseInt(starkInfo.starkStruct.steps[starkInfo.starkStruct.steps.length-1].nBits) %>][3];
    
    component vA = StarkVerifier();

    vA.publics <== publics;
    vA.root1 <== root1;
    vA.root2 <== root2;
    vA.root3 <== root3;
    vA.root4 <== root4;
    vA.evals <== evals;
    vA.s0_vals1 <== s0_vals1;
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    vA.s0_vals2 <== s0_vals2;
<% } -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    vA.s0_vals3 <== s0_vals3;
<% } -%>    
    vA.s0_vals4 <== s0_vals4;
    vA.s0_valsC <== s0_valsC;
    vA.s0_siblings1 <== s0_siblings1;
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    vA.s0_siblings2 <== s0_siblings2;
<% } -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    vA.s0_siblings3 <== s0_siblings3;
<% } -%>
    vA.s0_siblings4 <== s0_siblings4;
    vA.s0_siblingsC <== s0_siblingsC;
<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    vA.s<%- s %>_root <== s<%- s %>_root;
<% }                                                  -%>
<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    vA.s<%- s %>_vals <== s<%- s %>_vals;
    vA.s<%- s %>_siblings <== s<%- s %>_siblings;
<% }                                                  -%>
    vA.finalPol <== finalPol;

}

component main {public [publics, rootC]}= Main();