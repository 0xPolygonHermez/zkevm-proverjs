pragma circom 2.1.0;

/*
aggregatorAddr -> 160   -> 160
oldStateRoot -> 256     -> 416
oldAccInputHash -> 256  -> 672
oldBathcNum -> 64       -> 736
chainId -> 64           -> 800
forkId -> 64            -> 864
newStateRoot -> 256     -> 1120
newAccInputHash -> 256  -> 1376
newLocalExitRoot -> 256 -> 1632
newBatchNum -> 64       -> 1696

Total: 1696
*/

include "sha256/sha256.circom";
include "bitify.circom";
include "lessthangl.circom";
include "recursivef.verifier.circom";


template Main() {
    signal output publicsHash;

    signal input aggregatorAddr;

    signal input publics[44];
    signal input root1;
    signal input root2;
    signal input root3;
    signal input root4;

    signal input evals[<%- starkInfo.evMap.length %>][3]; // Evaluations of the set polynomials at a challenge value z and gz

    signal input s0_vals1[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm1_n %>];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    signal input s0_vals2[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm2_n %>];
<% } -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    signal input s0_vals3[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm3_n %>];
<% } -%>
    signal input s0_vals4[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm4_n %>];
    signal input s0_valsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.nConstants %>];
    signal input s0_siblings1[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[0].nBits) - 1)/4)+1 %>][16];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    signal input s0_siblings2[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[0].nBits) - 1)/4)+1 %>][16];
<% } -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    signal input s0_siblings3[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[0].nBits) - 1)/4)+1 %>][16];
<% } -%>
    signal input s0_siblings4[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[0].nBits) - 1)/4)+1 %>][16];
    signal input s0_siblingsC[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[0].nBits) - 1)/4)+1 %>][16];

<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_root;
<% }                                                  -%>

<% for (let s=1; s< starkInfo.starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_vals[<%- starkInfo.starkStruct.nQueries %>][<%- (1 << parseInt(starkInfo.starkStruct.steps[s-1].nBits - starkInfo.starkStruct.steps[s].nBits))*3 %>];
    signal input s<%- s %>_siblings[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[s].nBits) -1) /4) +1 %>][16];
<% }                                                  -%>

    signal input finalPol[<%- 1 << parseInt(starkInfo.starkStruct.steps[starkInfo.starkStruct.steps.length-1].nBits) %>][3];


    component sv = StarkVerifier();
    sv.publics <== publics;
    sv.root1 <== root1;
    sv.root2 <== root2;
    sv.root3 <== root3;
    sv.root4 <== root4;

    sv.evals <== evals;

    sv.s0_vals1 <== s0_vals1;
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    sv.s0_vals2 <== s0_vals2;
<% } -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    sv.s0_vals3 <== s0_vals3;
<% } -%>
    sv.s0_vals4 <== s0_vals4;
    sv.s0_valsC <== s0_valsC;

    sv.s0_siblings1 <== s0_siblings1;
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    sv.s0_siblings2 <== s0_siblings2;
<% } -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    sv.s0_siblings3 <== s0_siblings3;
<% } -%>
    sv.s0_siblings4 <== s0_siblings4;
    sv.s0_siblingsC <== s0_siblingsC;

<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    sv.s<%- s %>_root <== s<%- s %>_root;
<% }                                                  -%>
<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    sv.s<%- s %>_vals <== s<%- s %>_vals;
    sv.s<%- s %>_siblings <== s<%- s %>_siblings;
<% } -%>    

    sv.finalPol <== finalPol;

    component publicsHasher = Sha256(1696);

    signal n2bOldStateRoot[8][32];
    for (var i=0; i<8; i++) {
        n2bOldStateRoot[i] <== Num2Bits(32)(publics[0 + i]);
        for (var j=0; j<32; j++) {
            publicsHasher.in[32*(8-i) - 1 -j] <== n2bOldStateRoot[i][j];
        }
    }

    for (var i = 0; i < 4; i++) {
        _<== LessThanGoldilocks()(publics[0 + 2*i] + (1 << 32) * publics[0 + 2*i + 1]);
    }

    signal n2bOldAccInputHash[8][32];
    for (var i=0; i<8; i++) {
        n2bOldAccInputHash[i] <== Num2Bits(32)(publics[8 + i]);
        for (var j=0; j<32; j++) {
            publicsHasher.in[256 + 32*(8-i) - 1 -j] <== n2bOldAccInputHash[i][j];
        }
    }

    // Do 63 bits to avoid aliasing
    signal n2bOldBatchNum[63] <== Num2Bits(63)(publics[16]);
    for (var i=0; i<63; i++) {
        publicsHasher.in[512 + 64 - 1 -i] <== n2bOldBatchNum[i];
    }
    publicsHasher.in[512] <== 0;

    signal n2bChainId[63] <== Num2Bits(63)(publics[17]);
    for (var i=0; i<63; i++) {
        publicsHasher.in[576 + 64 - 1 -i] <== n2bChainId[i];
    }
    publicsHasher.in[576] <== 0;

    signal n2bForkId[63] <== Num2Bits(63)(publics[18]);
    for (var i=0; i<63; i++) {
        publicsHasher.in[640 + 64 - 1 -i] <== n2bForkId[i];
    }
    publicsHasher.in[640] <== 0;

    signal n2bNewStateRoot[8][32];
    for (var i=0; i<8; i++) {
        n2bNewStateRoot[i] <== Num2Bits(32)(publics[19 + i]);
        for (var j=0; j<32; j++) {
            publicsHasher.in[704 + 32*(8-i) - 1 -j] <== n2bNewStateRoot[i][j];
        }
    }

    for (var i = 0; i < 4; i++) {
        _<== LessThanGoldilocks()(publics[19 + 2*i] + (1 << 32)*publics[19 + 2*i + 1]);
    }

    signal n2bNewAccInputHash[8][32];
    for (var i=0; i<8; i++) {
        n2bNewAccInputHash[i] <== Num2Bits(32)(publics[27+i]);
        for (var j=0; j<32; j++) {
            publicsHasher.in[960 + 32*(8-i) - 1 -j] <== n2bNewAccInputHash[i][j];
        }
    }

    signal n2bNewLocalExitRoot[8][32];
    for (var i=0; i<8; i++) {
        n2bNewLocalExitRoot[i] <== Num2Bits(32)(publics[35 + i]);
        for (var j=0; j<32; j++) {
            publicsHasher.in[1216 + 32*(8-i) - 1 -j] <== n2bNewLocalExitRoot[i][j];
        }
    }

    signal n2bNewBatchNum[63] <== Num2Bits(63)(publics[43]);
    for (var i=0; i<63; i++) {
        publicsHasher.in[1472 + 64 - 1 -i] <== n2bNewBatchNum[i];
    }
    publicsHasher.in[1472] <== 0;

    signal n2bAggregatorAddr[160] <== Num2Bits(160)(aggregatorAddr);
    for (var i=0; i<160; i++) {
        publicsHasher.in[1696 - 1 -i] <== n2bAggregatorAddr[i];
    }
    
    component b2nPublicsHash = Bits2Num(256);
    for (var i = 0; i < 256; i++) {
        b2nPublicsHash.in[i] <== publicsHasher.out[255-i];
    }

    publicsHash <== b2nPublicsHash.out;
}

component main = Main();