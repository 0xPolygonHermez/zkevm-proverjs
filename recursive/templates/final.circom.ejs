pragma circom 2.1.0;

/*
oldStateRoot (256 bits)                                 -> 256
oldBatchAccInputHash / oldBlobAccInputHash (256 bits)   -> 512
oldBatchNum / oldBlobNum (64 bits)                      -> 576
chainId (64 bits)                                       -> 640
forkId (64 bits)                                        -> 704
newStateRoot (256 bits)                                 -> 960
newBatchAccInputHash / newBlobAccInputHash (256 bits)   -> 1216
newLocalExitRoot (256 bits)                             -> 1472
newBatchNum / newBlobNum (64 bits)                      -> 1536
aggregatorAddr (160 bits)                               -> 1696
Total: 1696 bits
*/

include "sha256/sha256.circom";
include "bitify.circom";
include "lessthangl.circom";
include "recursivef.verifier.circom";


template Main() {
    signal output publicsHash;

    signal input aggregatorAddr;

    signal input publics[<%- starkInfo.nPublics %>];

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
    signal input root<%- s %>;
<%  } -%>

    signal input evals[<%- starkInfo.evMap.length %>][3]; // Evaluations of the set polynomials at a challenge value z and gz

    signal input s0_valsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.nConstants %>];
    signal input s0_siblingsC[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[0].nBits) - 1)/4)+1 %>][16];

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
<%     if (starkInfo.mapSectionsN[`cm${s}_2ns`] > 0) { -%>
    signal input s0_vals<%- s %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cm${s}_n`] %>];
    signal input s0_siblings<%- s %>[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[0].nBits) - 1)/4)+1 %>][16];
<%     } -%>
<% } -%>

<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_root;
<% }                                                  -%>

<% for (let s=1; s< starkInfo.starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_vals[<%- starkInfo.starkStruct.nQueries %>][<%- (1 << parseInt(starkInfo.starkStruct.steps[s-1].nBits - starkInfo.starkStruct.steps[s].nBits))*3 %>];
    signal input s<%- s %>_siblings[<%- starkInfo.starkStruct.nQueries %>][<%- Math.floor((parseInt(starkInfo.starkStruct.steps[s].nBits) -1) /4) +1 %>][16];
<% }                                                  -%>

    signal input finalPol[<%- 1 << parseInt(starkInfo.starkStruct.steps[starkInfo.starkStruct.steps.length-1].nBits) %>][3];


    component sv = StarkVerifier();
    sv.publics <== publics;
<%  for (let s=1; s<=nStages + 1; ++s) { -%>
    sv.root<%- s %> <== root<%- s %>;
<% } -%>

    sv.evals <== evals;

    sv.s0_valsC <== s0_valsC;
    sv.s0_siblingsC <== s0_siblingsC;

<%  for (let s=1; s<=nStages + 1; ++s) { -%>
<%     if (starkInfo.mapSectionsN[`cm${s}_2ns`] > 0) { -%>
    sv.s0_vals<%- s %> <== s0_vals<%- s %>;
    sv.s0_siblings<%- s %> <== s0_siblings<%- s %>;
<%     } -%>
<% } -%>
 
<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    sv.s<%- s %>_root <== s<%- s %>_root;
<% }                                                  -%>
<% for (let s=1; s<starkInfo.starkStruct.steps.length; s++) {   -%>
    sv.s<%- s %>_vals <== s<%- s %>_vals;
    sv.s<%- s %>_siblings <== s<%- s %>_siblings;
<% } -%>    

    sv.finalPol <== finalPol;

    component publicsHasher = Sha256(1696);

    signal n2bOldStateRoot[8][32];
    for (var i=0; i<8; i++) {
        n2bOldStateRoot[i] <== Num2Bits(32)(publics[0 + i]);
        for (var j=0; j<32; j++) {
            publicsHasher.in[32*(8-i) - 1 -j] <== n2bOldStateRoot[i][j];
        }
    }

    for (var i = 0; i < 4; i++) {
        _<== LessThanGoldilocks()(publics[0 + 2*i] + (1 << 32) * publics[0 + 2*i + 1]);
    }

    signal n2bOldAccInputHash[8][32];
    for (var i=0; i<8; i++) {
        n2bOldAccInputHash[i] <== Num2Bits(32)(publics[8 + i]);
        for (var j=0; j<32; j++) {
            publicsHasher.in[256 + 32*(8-i) - 1 -j] <== n2bOldAccInputHash[i][j];
        }
    }

    // Do 63 bits to avoid aliasing
    signal n2bOldBatchNum[63] <== Num2Bits(63)(publics[16]);
    for (var i=0; i<63; i++) {
        publicsHasher.in[512 + 64 - 1 -i] <== n2bOldBatchNum[i];
    }
    publicsHasher.in[512] <== 0;

    signal n2bChainId[63] <== Num2Bits(63)(publics[17]);
    for (var i=0; i<63; i++) {
        publicsHasher.in[576 + 64 - 1 -i] <== n2bChainId[i];
    }
    publicsHasher.in[576] <== 0;

    signal n2bForkId[63] <== Num2Bits(63)(publics[18]);
    for (var i=0; i<63; i++) {
        publicsHasher.in[640 + 64 - 1 -i] <== n2bForkId[i];
    }
    publicsHasher.in[640] <== 0;

    signal n2bNewStateRoot[8][32];
    for (var i=0; i<8; i++) {
        n2bNewStateRoot[i] <== Num2Bits(32)(publics[19 + i]);
        for (var j=0; j<32; j++) {
            publicsHasher.in[704 + 32*(8-i) - 1 -j] <== n2bNewStateRoot[i][j];
        }
    }

    for (var i = 0; i < 4; i++) {
        _<== LessThanGoldilocks()(publics[19 + 2*i] + (1 << 32)*publics[19 + 2*i + 1]);
    }

    signal n2bNewAccInputHash[8][32];
    for (var i=0; i<8; i++) {
        n2bNewAccInputHash[i] <== Num2Bits(32)(publics[27+i]);
        for (var j=0; j<32; j++) {
            publicsHasher.in[960 + 32*(8-i) - 1 -j] <== n2bNewAccInputHash[i][j];
        }
    }

    signal n2bNewLocalExitRoot[8][32];
    for (var i=0; i<8; i++) {
        n2bNewLocalExitRoot[i] <== Num2Bits(32)(publics[35 + i]);
        for (var j=0; j<32; j++) {
            publicsHasher.in[1216 + 32*(8-i) - 1 -j] <== n2bNewLocalExitRoot[i][j];
        }
    }

    signal n2bNewBatchNum[63] <== Num2Bits(63)(publics[43]);
    for (var i=0; i<63; i++) {
        publicsHasher.in[1472 + 64 - 1 -i] <== n2bNewBatchNum[i];
    }
    publicsHasher.in[1472] <== 0;

    signal n2bAggregatorAddr[160] <== Num2Bits(160)(aggregatorAddr);
    for (var i=0; i<160; i++) {
        publicsHasher.in[1696 - 1 -i] <== n2bAggregatorAddr[i];
    }
    
    component b2nPublicsHash = Bits2Num(256);
    for (var i = 0; i < 256; i++) {
        b2nPublicsHash.in[i] <== publicsHasher.out[255-i];
    }

    publicsHash <== b2nPublicsHash.out;
}

component main = Main();