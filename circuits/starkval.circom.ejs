pragma circom 2.0.2;

include "../node_modules/circomlib/circuits/binsum.circom";
include "../node_modules/circomlib/circuits/poseidon.circom";
include "../circuits/merklemultipol.circom";
include "../circuits/merklegroup.circom";
include "../circuits/merkle.circom";
include "../circuits/fft.circom";
include "../circuits/poleval.circom";
include "../circuits/exp.circom";

include "../circuits/fields2idxs.circom";

template StarkEvaluationCalculator() {

<% for (let i=0; i<pil.publics.length; i++) { %>    signal input <%- pil.publics[i].name %>;
<% } %>
    signal input tree1[<%- calculator.nTree1 %>];
    signal input tree2[<%- calculator.nTree2 %>];
    signal input tree3[<%- calculator.nTree3 %>];
    signal input treeC[<%- calculator.nConst %>];
    signal input tree1p[<%- calculator.nTree1 %>];
    signal input tree2p[<%- calculator.nTree2 %>];
    signal input tree3p[<%- calculator.nTree3 %>];
    signal input treeCp[<%- calculator.nConst %>];
    signal input u;
    signal input defVal;
    signal input gamma;
    signal input beta;
    signal input v;
    signal output out;

    signal im[<%- calculator.nIm %>];
    <% 
        function ref(r) {
            if (r.type == "tree1") {
                if (r.next) {
                    return "tree1p[" + r.id + "]";
                } else {
                    return "tree1[" + r.id + "]";
                }
            } else if (r.type == "tree2") {
                if (r.next) {
                    return "tree2p[" + r.id + "]";
                } else {
                    return "tree2[" + r.id + "]";
                }
            } else if (r.type == "tree3") {
                if (r.next) {
                    return "tree3p[" + r.id + "]";
                } else {
                    return "tree3[" + r.id + "]";
                }
            } else if (r.type == "const") {
                if (r.next) {
                    return "treeCp[" + r.id + "]";
                } else {
                    return "treeC[" + r.id + "]";
                }
            } else if (r.type == "im") {
                return "im[" + r.id + "]";
            } else if (r.type == "challange") {
                return r.name;  
            } else if (r.type == "public") {
                return r.name;  
            } else {
                throw new Error(`invalid ref type: ${ref.type}`);
            }
        }
    %>
    <% for(let i=0; i<calculator.instructions.length; i++) { 
    %><% let inst = calculator.instructions[i]; 
    %><% if (inst.op == "add") { %><%- ref(inst.res) %> <== <%- ref(inst.values[0]) %> + <%- ref(inst.values[1]) %>; 
    <% } else if (inst.op == "sub") { %><%- ref(inst.res) %> <== <%- ref(inst.values[0]) %> - <%- ref(inst.values[1]) %>;
    <% } else if (inst.op == "mul") { %><%- ref(inst.res) %> <== <%- ref(inst.values[0]) %> * <%- ref(inst.values[1]) %>;
    <% } else if (inst.op == "neg") { %><%- ref(inst.res) %> <== -<%- ref(inst.values[0]) %>;
    <% } else if (inst.op == "addc") { %><%- ref(inst.res) %> <== <%- ref(inst.values[0]) %> + <%- inst.const %>;
    <% } else if (inst.op == "mulc") { %><%- ref(inst.res) %> <== <%- ref(inst.values[0]) %> * <%- inst.const %>;
    <% } else { throw new Error(`Invalid op: ${inst.op}`); -%>
    <% } -%>
    <% } -%>

    out <== <%- ref(calculator.output) %>;
}


template StarkVal() {

<% for (let i=0; i<pil.publics.length; i++) { %>    signal input <%- pil.publics[i].name %>;
<% } %>

    signal input s0_rootUp1;
    signal input s0_rootUp2;
    signal input s0_rootUp3;
    <% 
        let groupSizeBitsUp = [];
        let nGroupsBitsUp = [];
        let groupSizeBitsDown = [];
        let nGroupsBitsDown = [];
        let nSiblingsUp = [];
        let nSiblingsDownL = [];
        let nSiblingsDownH = [];

        groupSizeBitsUp[0] = starkStruct.nBitsExt - starkStruct.steps[0].nBits;
        nGroupsBitsUp[0] = starkStruct.nBitsExt - groupSizeBitsUp[0];
        groupSizeBitsDown[0] = starkStruct.steps.length>1 ? 
            starkStruct.steps[0].nBits - starkStruct.steps[1].nBits : 
            0;
        nGroupsBitsDown[0] = starkStruct.steps[0].nBits - groupSizeBitsDown[0];

        nSiblingsUp[0] = Math.floor((nGroupsBitsUp[0] - 1) / 4)+1;
        nSiblingsDownL[0] = Math.floor((groupSizeBitsDown[0] - 1) / 4)+1;
        nSiblingsDownH[0] = Math.floor((nGroupsBitsDown[0] - 1) / 4)+1;
    %>
    signal input s0_valsUp1[<%- starkStruct.steps[0].nQueries %>][<%- 1 << groupSizeBitsUp[0] %>][<%- calculator.nTree1 %>];
    signal input s0_valsUp2[<%- starkStruct.steps[0].nQueries %>][<%- 1 << groupSizeBitsUp[0] %>][<%- calculator.nTree2 %>];
    signal input s0_valsUp3[<%- starkStruct.steps[0].nQueries %>][<%- 1 << groupSizeBitsUp[0] %>][<%- calculator.nTree3 %>];
    signal input s0_valsUpC[<%- starkStruct.steps[0].nQueries %>][<%- 1 << groupSizeBitsUp[0] %>][<%- calculator.nConst %>];
    signal input s0_valsUp1p[<%- starkStruct.steps[0].nQueries %>][<%- 1 << groupSizeBitsUp[0] %>][<%- calculator.nTree1 %>];
    signal input s0_valsUp2p[<%- starkStruct.steps[0].nQueries %>][<%- 1 << groupSizeBitsUp[0] %>][<%- calculator.nTree2 %>];
    signal input s0_valsUp3p[<%- starkStruct.steps[0].nQueries %>][<%- 1 << groupSizeBitsUp[0] %>][<%- calculator.nTree3 %>];
    signal input s0_valsUpCp[<%- starkStruct.steps[0].nQueries %>][<%- 1 << groupSizeBitsUp[0] %>][<%- calculator.nConst %>];
    signal input s0_siblingsUp1[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsUp[0] %>][16];
    signal input s0_siblingsUp2[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsUp[0] %>][16];
    signal input s0_siblingsUp3[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsUp[0] %>][16];
    signal input s0_siblingsUpC[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsUp[0] %>][16];
    signal input s0_siblingsUp1p[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsUp[0] %>][16];
    signal input s0_siblingsUp2p[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsUp[0] %>][16];
    signal input s0_siblingsUp3p[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsUp[0] %>][16];
    signal input s0_siblingsUpCp[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsUp[0] %>][16];
    signal input s0_rootDown;
    signal input s0_valsDown[<%- starkStruct.steps[0].nQueries %>];
    signal input s0_siblingsDownL[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsDownL[0] %>][16];
    signal input s0_siblingsDownH[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsDownH[0] %>][16];
    

<% for (let s = 1; s<starkStruct.steps.length; s++) { %>
    <% 
        groupSizeBitsUp[s] = starkStruct.steps[s-1].nBits - starkStruct.steps[s].nBits;
        nGroupsBitsUp[s] = starkStruct.steps[s-1].nBits - groupSizeBitsUp[s];
        groupSizeBitsDown[s] = starkStruct.steps.length>s+1 ? 
            starkStruct.steps[s].nBits - starkStruct.steps[s+1].nBits : 
            0;
        nGroupsBitsDown[s] = starkStruct.steps[s].nBits - groupSizeBitsDown[s];

        nSiblingsUp[s] = Math.floor((nGroupsBitsUp[s] - 1) / 4)+1;
        nSiblingsDownL[s] = Math.floor((groupSizeBitsDown[s] - 1) / 4)+1;
        nSiblingsDownH[s] = Math.floor((nGroupsBitsDown[s] - 1) / 4)+1;
    %>
    signal input s<%- s %>_valsUp[<%- starkStruct.steps[s].nQueries %>][<%- 1 << (starkStruct.steps[s-1].nBits-starkStruct.steps[s].nBits) %>];
    signal input s<%- s %>_siblingsUp[<%- starkStruct.steps[s].nQueries %>][<%- nSiblingsUp[s] %>][16];
    signal input s<%- s %>_rootDown;
    signal input s<%- s %>_valsDown[<%- starkStruct.steps[0].nQueries %>];
    signal input s<%- s %>_siblingsDownL[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsDownL[s] %>][16];
    signal input s<%- s %>_siblingsDownH[<%- starkStruct.steps[0].nQueries %>][<%- nSiblingsDownH[s] %>][16];
<% } %>

<%  const nLast = 1 << starkStruct.steps[starkStruct.steps.length-1].nBits %>
    signal input lastVals [<%- nLast %>];       

    signal s0_rootUpC;
    s0_rootUpC <== <%- constRoot %>;

//////////////////
// Challanges
//////////////////

<% 
    var ch_used = false;
    var ch_state = "0";
    var ch_isZero = true;
    var ch_tmp = 0;

    function ch_get(sName, define) {
        let S = "";
        if (define) {
            S = S + `   signal ${sName};\n`;
        }
        if (ch_used) {
            S = S + `   component chHash_${ch_tmp} = Poseidon(1);\n`
            S = S + `   chHash_${ch_tmp}.inputs[0] <== ${ch_state};\n`

            ch_state = `chHash_${ch_tmp}.out`;
            ch_isZero = false;
            ch_tmp ++;
        }
        ch_used=true;
        S = S + `   ${sName} <== ${ch_state};\n`;
        return S;
    }

    function ch_put(sName) {
        let S = "";
        if (ch_isZero) {
            ch_state = sName;
        } else {
            S = S + `   component chHash_${ch_tmp} = Poseidon(2);\n`
            S = S + `   chHash_${ch_tmp}.inputs[0] <== ${ch_state};\n`
            S = S + `   chHash_${ch_tmp}.inputs[1] <== ${sName};\n`

            ch_state = `chHash_${ch_tmp}.out`;
            ch_isZero = false;
            ch_tmp ++;
        }
        ch_used = false;
        return S;
    }

    function ch_getIndexes(sSname, n, nBits) {
        let S = "";
        const totalBits = n*nBits;
        const NFields = Math.floor((totalBits - 1)/253)+1;
        S = S + `   component ${sSname} = Fields2Idxs(${n}, ${nBits});\n`;
        for (let i=0; i<NFields; i++) {
            S += ch_get(`${sSname}.in[${i}]`);
        }

        return S;
    }

%>

<%- ch_put("s0_rootUp1") %>
<%- ch_get("u", true) %>
<%- ch_get("defVal", true) %>
<%- ch_put("s0_rootUp2") %>
<%- ch_get("gamma", true) %>
<%- ch_get("beta", true) %>
<%- ch_put("s0_rootUp3") %>
<%- ch_get("v", true) %>
<% for (let s = 0; s<starkStruct.steps.length; s++) { %>
<%-     ch_get(`s${s}_specialX`, true) %>
<%-     ch_put(`s${s}_rootDown`) %>
<%-     ch_getIndexes(`s${s}_qIdx`, starkStruct.steps[s].nQueries, nGroupsBitsUp[s]) %>
<% } %>


//////////////////
// step0 Up Verification
//////////////////

    component s0_qIdxP[<%- starkStruct.steps[0].nQueries %>];
    component starkEvaluationCalculator[<%- starkStruct.steps[0].nQueries %>][<%- (1 << groupSizeBitsUp[0]) %>];
    component mpmVerifierTree1[<%- starkStruct.steps[0].nQueries %>];
    component mpmVerifierTree2[<%- starkStruct.steps[0].nQueries %>];
    component mpmVerifierTree3[<%- starkStruct.steps[0].nQueries %>];
    component mpmVerifierTreeC[<%- starkStruct.steps[0].nQueries %>];
    component mpmVerifierTree1p[<%- starkStruct.steps[0].nQueries %>];
    component mpmVerifierTree2p[<%- starkStruct.steps[0].nQueries %>];
    component mpmVerifierTree3p[<%- starkStruct.steps[0].nQueries %>];
    component mpmVerifierTreeCp[<%- starkStruct.steps[0].nQueries %>];
    for (var i = 0; i < <%- starkStruct.steps[0].nQueries %>; i++) {
        mpmVerifierTree1[i] = MerkleMultipol_GroupVerifier(<%- (1 << nGroupsBitsUp[0]) %>,  <%- (1 << groupSizeBitsUp[0]) %>, <%- calculator.nTree1 %>);
        mpmVerifierTree2[i] = MerkleMultipol_GroupVerifier(<%- (1 << nGroupsBitsUp[0]) %>,  <%- (1 << groupSizeBitsUp[0]) %>, <%- calculator.nTree2 %>);
        mpmVerifierTree3[i] = MerkleMultipol_GroupVerifier(<%- (1 << nGroupsBitsUp[0]) %>,  <%- (1 << groupSizeBitsUp[0]) %>, <%- calculator.nTree3 %>);
        mpmVerifierTreeC[i] = MerkleMultipol_GroupVerifier(<%- (1 << nGroupsBitsUp[0]) %>,  <%- (1 << groupSizeBitsUp[0]) %>, <%- calculator.nConst %>);
        mpmVerifierTree1p[i] = MerkleMultipol_GroupVerifier(<%- (1 << nGroupsBitsUp[0]) %>,  <%- (1 << groupSizeBitsUp[0]) %>, <%- calculator.nTree1 %>);
        mpmVerifierTree2p[i] = MerkleMultipol_GroupVerifier(<%- (1 << nGroupsBitsUp[0]) %>,  <%- (1 << groupSizeBitsUp[0]) %>, <%- calculator.nTree2 %>);
        mpmVerifierTree3p[i] = MerkleMultipol_GroupVerifier(<%- (1 << nGroupsBitsUp[0]) %>,  <%- (1 << groupSizeBitsUp[0]) %>, <%- calculator.nTree3 %>);
        mpmVerifierTreeCp[i] = MerkleMultipol_GroupVerifier(<%- (1 << nGroupsBitsUp[0]) %>,  <%- (1 << groupSizeBitsUp[0]) %>, <%- calculator.nConst %>);
    
        s0_qIdxP[i] = BinSum(<%- nGroupsBitsUp[0] %>, 2);
        for (var k=0; k< <%- nGroupsBitsUp[0] %>; k++) {
            mpmVerifierTree1[i].key[k] <== s0_qIdx.out[i][k];
            mpmVerifierTree2[i].key[k] <== s0_qIdx.out[i][k];
            mpmVerifierTree3[i].key[k] <== s0_qIdx.out[i][k];
            mpmVerifierTreeC[i].key[k] <== s0_qIdx.out[i][k];
            s0_qIdxP[i].in[0][k] <== s0_qIdx.out[i][k];
            if (k==1) {
                s0_qIdxP[i].in[1][k] <== 1;
            } else {
                s0_qIdxP[i].in[1][k] <== 0;
            }
        }
        for (var k=0; k< <%- nGroupsBitsUp[0] %>; k++) {
            mpmVerifierTree1p[i].key[k] <== s0_qIdxP[i].out[k];
            mpmVerifierTree2p[i].key[k] <== s0_qIdxP[i].out[k];
            mpmVerifierTree3p[i].key[k] <== s0_qIdxP[i].out[k];
            mpmVerifierTreeCp[i].key[k] <== s0_qIdxP[i].out[k];
        }
        for (var j=0; j< <%- nSiblingsUp[0] %>; j++) {
            for (var k=0; k<16; k++) {
                mpmVerifierTree1[i].siblings[j][k] <== s0_siblingsUp1[i][j][k];
                mpmVerifierTree2[i].siblings[j][k] <== s0_siblingsUp2[i][j][k];
                mpmVerifierTree3[i].siblings[j][k] <== s0_siblingsUp3[i][j][k];
                mpmVerifierTreeC[i].siblings[j][k] <== s0_siblingsUpC[i][j][k];
                mpmVerifierTree1p[i].siblings[j][k] <== s0_siblingsUp1p[i][j][k];
                mpmVerifierTree2p[i].siblings[j][k] <== s0_siblingsUp2p[i][j][k];
                mpmVerifierTree3p[i].siblings[j][k] <== s0_siblingsUp3p[i][j][k];
                mpmVerifierTreeCp[i].siblings[j][k] <== s0_siblingsUpCp[i][j][k];
            }
        }

        for (var j=0; j< <%- 1 << groupSizeBitsUp[0] %>; j++) {
            starkEvaluationCalculator[i][j] = StarkEvaluationCalculator();

<% for (let i=0; i<pil.publics.length; i++) { %>            starkEvaluationCalculator[i][j].<%- pil.publics[i].name %> <== <%- pil.publics[i].name %>;
<% } %>
            starkEvaluationCalculator[i][j].u <== u;
            starkEvaluationCalculator[i][j].defVal <== defVal;
            starkEvaluationCalculator[i][j].gamma <== gamma;
            starkEvaluationCalculator[i][j].beta <== beta;
            starkEvaluationCalculator[i][j].v <== v;

            for (var k=0; k< <%- calculator.nTree1 %>; k++) {
                starkEvaluationCalculator[i][j].tree1[k] <== s0_valsUp1[i][j][k];
                starkEvaluationCalculator[i][j].tree1p[k] <== s0_valsUp1p[i][j][k];
                mpmVerifierTree1[i].values[j][k] <== s0_valsUp1[i][j][k];
                mpmVerifierTree1p[i].values[j][k] <== s0_valsUp1p[i][j][k];
            }
            for (var k=0; k< <%- calculator.nTree2 %>; k++) {
                starkEvaluationCalculator[i][j].tree2[k] <== s0_valsUp2[i][j][k];
                starkEvaluationCalculator[i][j].tree2p[k] <== s0_valsUp2p[i][j][k];
                mpmVerifierTree2[i].values[j][k] <== s0_valsUp2[i][j][k];
                mpmVerifierTree2p[i].values[j][k] <== s0_valsUp2p[i][j][k];
            }
            for (var k=0; k< <%- calculator.nTree3 %>; k++) {
                starkEvaluationCalculator[i][j].tree3[k] <== s0_valsUp3[i][j][k];
                starkEvaluationCalculator[i][j].tree3p[k] <== s0_valsUp3p[i][j][k];
                mpmVerifierTree3[i].values[j][k] <== s0_valsUp3[i][j][k];
                mpmVerifierTree3p[i].values[j][k] <== s0_valsUp3p[i][j][k];
            }
            for (var k=0; k< <%- calculator.nConst %>; k++) {
                starkEvaluationCalculator[i][j].treeC[k] <== s0_valsUpC[i][j][k];
                starkEvaluationCalculator[i][j].treeCp[k] <== s0_valsUpCp[i][j][k];
                mpmVerifierTreeC[i].values[j][k] <== s0_valsUpC[i][j][k];
                mpmVerifierTreeCp[i].values[j][k] <== s0_valsUpCp[i][j][k];
            }
        }

        mpmVerifierTree1[i].root === s0_rootUp1;
        mpmVerifierTree2[i].root === s0_rootUp2;
        mpmVerifierTree3[i].root === s0_rootUp3;
        mpmVerifierTreeC[i].root === s0_rootUpC;
        mpmVerifierTree1p[i].root === s0_rootUp1;
        mpmVerifierTree2p[i].root === s0_rootUp2;
        mpmVerifierTree3p[i].root === s0_rootUp3;
        mpmVerifierTreeCp[i].root === s0_rootUpC;
    }

// Verifier Up


<% for (let s=1; s< starkStruct.steps.length; s++) { %>
    component s<%- s %>_gmVerifierUp[<%- starkStruct.steps[s].nQueries %>];
    for (var i=0; i< <%- starkStruct.steps[s].nQueries %>; i++) {
        s<%- s %>_gmVerifierUp[i] = MerkleGroup_GroupVerifier(<%- 1 << nGroupsBitsUp[s] %>, <%- 1 << groupSizeBitsUp[s] %>);
        for (var k=0; k< <%- 1 << groupSizeBitsUp[s] %>; k++ ) {
            s<%- s %>_gmVerifierUp[i].values[k] <== s<%- s %>_valsUp[i][k];
        }
        for (var j=0; j< <%- nSiblingsUp[s] %>; j++ ) {
            for (var k=0; k<16; k++) {
                s<%- s %>_gmVerifierUp[i].siblings[j][k] <== s<%- s %>_siblingsUp[i][j][k];
            }
        }
        for (var k=0; k< <%- nGroupsBitsUp[s] %>; k++) {
            s<%- s %>_gmVerifierUp[i].key[k] <== s<%- s %>_qIdx.out[i][k];
        }
        s<%- s %>_gmVerifierUp[i].root === s<%- s-1 %>_rootDown;
    }
<% } %>

// Verify down query

<% for (let s=0; s< starkStruct.steps.length; s++) { %>
    component s<%- s %>_gmVerifierDown[<%- starkStruct.steps[s].nQueries %>];
    for (var i=0; i< <%- starkStruct.steps[s].nQueries %>; i++) {
        s<%- s %>_gmVerifierDown[i] = MerkleGroup_ElementVerifier(<%- 1 << nGroupsBitsDown[s] %>, <%- 1 << groupSizeBitsDown[s] %>);
        s<%- s %>_gmVerifierDown[i].value <== s<%- s %>_valsDown[i];
        for (var j=0; j< <%- nSiblingsDownL[s] %>; j++ ) {
            for (var k=0; k<16; k++) {
                s<%- s %>_gmVerifierDown[i].siblingsL[j][k] <== s<%- s %>_siblingsDownL[i][j][k];
            }
        }
        for (var j=0; j< <%- nSiblingsDownH[s] %>; j++ ) {
            for (var k=0; k<16; k++) {
                s<%- s %>_gmVerifierDown[i].siblingsH[j][k] <== s<%- s %>_siblingsDownH[i][j][k];
            }
        }
        for (var k=0; k< <%- nGroupsBitsUp[s] %>; k++) {
            s<%- s %>_gmVerifierDown[i].key[k] <== s<%- s %>_qIdx.out[i][k];
        }
        s<%- s %>_gmVerifierDown[i].root === s<%- s %>_rootDown;
    }
<% } %>

// Linearity of the query

<% let shift = F.shift %>
<% for (let s=0; s< starkStruct.steps.length; s++) { %>
    component s<%- s %>_exp[<%- starkStruct.steps[s].nQueries %>];
    component s<%- s %>_ifft[<%- starkStruct.steps[s].nQueries %>];
    component s<%- s %>_polMulAxi[<%- starkStruct.steps[s].nQueries %>];
    component s<%- s %>_polEval[<%- starkStruct.steps[s].nQueries %>];

    
    for (var i=0; i< <%- starkStruct.steps[s].nQueries %>; i++) {
        s<%- s %>_exp[i] = Exp(<%- nGroupsBitsUp[s] %>);
        s<%- s %>_ifft[i] = IFFT(<%- 1 << groupSizeBitsUp[s] %>);
        s<%- s %>_polMulAxi[i] = PolMulAxi(<%- 1 << groupSizeBitsUp[s] %>);
        s<%- s %>_polEval[i] = PolEval(<%- 1 << groupSizeBitsUp[s] %>);
        s<%- s %>_exp[i].in <== <%- F.toString(F.inv( F.w[ groupSizeBitsUp[s] + nGroupsBitsUp[s] ])) %>;
        for (var k=0; k< <%- nGroupsBitsUp[s] %>; k++) {
            s<%- s %>_exp[i].exp[k] <== s<%- s %>_qIdx.out[i][k];
        }
        for (var k=0; k< <%- 1 << groupSizeBitsUp[s] %>; k++) {
<% if (s==0) { -%>
            s<%- s %>_ifft[i].in[k] <== starkEvaluationCalculator[i][k].out;
<% } else { -%>
            s<%- s %>_ifft[i].in[k] <== s<%- s %>_valsUp[i][k];
<% } -%>
        }
        s<%- s %>_polMulAxi[i].init <== 1;
        s<%- s %>_polMulAxi[i].acc <== <%- F.toString(F.inv(shift)) %> * s<%- s %>_exp[i].out;
        for (var k=0; k< <%- 1 << groupSizeBitsUp[s] %>; k++) {
            s<%- s %>_polMulAxi[i].in[k] <== s<%- s %>_ifft[i].out[k];
        }
        for (var k=0; k< <%- 1 << groupSizeBitsUp[s] %>; k++) {
            s<%- s %>_polEval[i].coefs[k] <== s<%- s %>_polMulAxi[i].out[k];
        }
        s<%- s %>_polEval[i].x <== s<%- s %>_specialX;
        s<%- s %>_polEval[i].y === s<%- s %>_valsDown[i];
    }
<%  for (let j=0; j<groupSizeBitsUp[s]; j++) shift = F.mul(shift, shift); %>
<% } %>

// Last Merkle TODO
    component lastMerkle = Merkle_Merkelize(<%- nLast %> );
    for (var k=0; k< <%- nLast %>; k++ ){
        lastMerkle.values[k] <== lastVals[k];
    }

    lastMerkle.root === s<%- starkStruct.steps.length-1 %>_rootDown;

// Last FFT

<% const maxDeg =  nLast >> (starkStruct.nBitsExt - starkStruct.nBits); %>
    component lastIFFT = IFFT(<%- nLast %> );

    for (var k=0; k< <%- nLast %>; k++ ){
        lastIFFT.in[k] <== lastVals[k];
    }

    for (var k= <%- maxDeg %>; k< <%- nLast %>; k++ ) {
        lastIFFT.out[k] === 0;
    }

}

<% 
function getPublics() {
    let S = [];
    for (let i=0; i<pil.publics.length; i++) {
        if (i>0) S = S +',';
        S = S + pil.publics[i].name;
    }
    return S;
}
%>

component main {public [<%- getPublics() %>]} = StarkVal();