pragma circom 2.0.2;

include "utils.circom";

function rev(a, nBits) {
    var revTable[16] = [ 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];

    var acc = 0;
    for (var i=0; i<8; i++) {
        acc = acc << 4;
        acc += revTable[(a >> (i*4)) & 0xF];
    }

    acc = acc >> (32 - nBits);

    return acc;
}

function roots(i) {
    var roots[29] = [
        1,
        21888242871839275222246405745257275088548364400416034343698204186575808495616,
        21888242871839275217838484774961031246007050428528088939761107053157389710902,
        19540430494807482326159819597004422086093766032135589407132600596362845576832,
        14940766826517323942636479241147756311199852622225275649687664389641784935947,
        4419234939496763621076330863786513495701855246241724391626358375488475697872,
        9088801421649573101014283686030284801466796108869023335878462724291607593530,
        10359452186428527605436343203440067497552205259388878191021578220384701716497,
        3478517300119284901893091970156912948790432420133812234316178878452092729974,
        6837567842312086091520287814181175430087169027974246751610506942214842701774,
        3161067157621608152362653341354432744960400845131437947728257924963983317266,
        1120550406532664055539694724667294622065367841900378087843176726913374367458,
        4158865282786404163413953114870269622875596290766033564087307867933865333818,
        197302210312744933010843010704445784068657690384188106020011018676818793232,
        20619701001583904760601357484951574588621083236087856586626117568842480512645,
        20402931748843538985151001264530049874871572933694634836567070693966133783803,
        421743594562400382753388642386256516545992082196004333756405989743524594615,
        12650941915662020058015862023665998998969191525479888727406889100124684769509,
        11699596668367776675346610687704220591435078791727316319397053191800576917728,
        15549849457946371566896172786938980432421851627449396898353380550861104573629,
        17220337697351015657950521176323262483320249231368149235373741788599650842711,
        13536764371732269273912573961853310557438878140379554347802702086337840854307,
        12143866164239048021030917283424216263377309185099704096317235600302831912062,
        934650972362265999028062457054462628285482693704334323590406443310927365533,
        5709868443893258075976348696661355716898495876243883251619397131511003808859,
        19200870435978225707111062059747084165650991997241425080699860725083300967194,
        7419588552507395652481651088034484897579724952953562618697845598160172257810,
        2082940218526944230311718225077035922214683169814847712455127909555749686340
    ];
    return roots[i];
}


template BitReverse(n) {
    signal input in[n];
    signal output out[n];

    var nBits = log2(n);

    var nDiv2 = n>>1;
    var ri;
    for (var i=0; i< n; i++) {
        ri = rev(i, nBits);
        if (i>ri) {
            out[i] <== in[ri];
            out[ri] <== in[i];
        } else if (i==ri) {
            out[i] <== in[i];
        }
    }
}


template FFT(n) {
    signal input in[n];
    signal output out[n];

    var nBits = log2(n);

    assert( (1 << nBits) == n);
    assert(nBits <= 28);

    signal buffers[nBits+1][n];

    component bitReverse = BitReverse(n);

    for (var i=0; i<n; i++) {
        bitReverse.in[i] <== in[i];
    }

    for (var i=0; i<n; i++) {
        buffers[0][i] <== bitReverse.out[i];
    }

    var m, wm, w, mdiv2;
    for (var s=1; s<=nBits; s++) {
        m = 1 << s;
        mdiv2 = m >> 1;
        wm = roots(s);
        for (var k=0; k<n; k+= m) {
            w = 1;
            for (var j=0; j<mdiv2; j++) {
                buffers[s][k+j] <== buffers[s-1][k+j] + w*buffers[s-1][k+j+mdiv2];
                buffers[s][k+j+mdiv2] <== buffers[s-1][k+j] - w*buffers[s-1][k+j+mdiv2];
                w=w*wm;
            }
        }
    }

    for (var i=0; i<n; i++) {
        out[i] <== buffers[nBits][i];
    }
}

template IFFT(n) {
    signal input in[n];
    signal output out[n];

    component fft = FFT(n);

    for (var i=0; i<n; i++) {
        fft.in[i] <== in[i];
    }

    var twoinv = 1 /n;

    for (var i=0; i<n; i++) {
        out[i] <== fft.out[ (n-i)%n ] * twoinv;
    }
}

template FFTcoset(n, shift) {
    signal input in[n];
    signal output out[n];

    component fft = FFT(n);

    var s = 1;
    for (var i=0; i<n; i++) {
        fft.in[i] <== in[i]*s;
        s = s*shift;
    }

    for (var i=0; i<n; i++) {
        out[i] <== fft.out[ i ];
    }
}

template IFFTcoset(n, shift) {
    signal input in[n];
    signal output out[n];

    component ifft = IFFT(n);

    for (var i=0; i<n; i++) {
        ifft.in[i] <== in[i];
    }

    var shiftinv = 1/shift;

    var s = 1;
    for (var i=0; i<n; i++) {
        out[i] <== ifft.out[i] * s;
        s = s* shiftinv;
    }
}

template PolMulAxi(n) {
    signal input in[n];
    signal input init;
    signal input acc;
    signal output out[n];

    signal w[n];
    w[0] <== init;

    for (var i=0; i<n; i++) {
        out[i] <== in[i] * w[i];
        if (i<n-1) {
            w[i+1] <== w[i]*acc;
        }
    }
}