
/*
    Equations:

    ===============  256 bits =======================================

    EQ0:   A(x1) * B(y1) + C(x2) = D (y2) * 2 ** 256 + op (y3)   - selEq[0]

    EQ1:   s * x2 - s * x1 - y2 + y1 + (q0 * p1)   lambda - ADD  - selEq[1]
    EQ2:   2 * s * y1 - 3 * x1 * x1 + (q0 * p1)    lambda - DBL  - selEq[2]
    EQ3:   s * s - x1 - x2 - x3 + (q1 * p1)        x3            - selEq[1] + selEq[2]
    EQ4:   s * x1 - s * x3 - y1 - y3 + (q2 * p1)   y3            - selEq[1] + selEq[2]

    EQ5:   x1 * x2 - y1 * y2 - x3 + (q1 * p2)                    - selEq[3]
    EQ6:   y1 * x2 + x1 * y2 - y3 + (q2 * p2)                    - selEq[3]

	EQ7:   x1 + x2 - x3 + (q1 * p2)                              - selEq[4]
	EQ8:   y1 + y2 - y3 + (q2 * p2)                              - selEq[4]

	EQ9:   x1 - x2 - x3 + (q1 * p2)                              - selEq[5]
	EQ10:  y1 - y2 - y3 + (q2 * p2)                              - selEq[5]

    EQ11:  A(x1) * B(y1) + C(x2) - op(y3) - q1 * D(y2) * 2**256 - q0 * D(y2)         - selEq[6]

    ===============  384 bits =======================================

    EQ12:  A(x1) * B(y1) + C(x2) - op(y3) - q1 * D(y2) * 2**256 - q0 * D(y2)         - selEq[7]

    EQ13:  x1 * x2 - y1 * y2 - x3 + (q1 * p2)                    - selEq[8]
    EQ14:  y1 * x2 + x1 * y2 - y3 + (q2 * p2)                    - selEq[8]

	EQ15:  x1 + x2 - x3 + (q1 * p2)                              - selEq[9]
	EQ16:  y1 + y2 - y3 + (q2 * p2)                              - selEq[9]

	EQ17:  x1 - x2 - x3 + (q1 * p2)                              - selEq[10]
	EQ18:  y1 - y2 - y3 + (q2 * p2)                              - selEq[10]

	EQ19:  256to384                                              - selEq[11]


    where p1 refers to the base field order of:
        · Secp256k1:  0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE FFFF FC2F
    and p2 refers to the base field order of:
        · BN254:      0x3064 4E72 E131 A029 B850 45B6 8181 585D 9781 6A91 6871 CA8D 3C20 8C16 D87C FD47
*/
include "global.pil";

namespace Arith(%N);

    pol constant GL_SIGNED_22BITS;

    pol commit x1[16];
    pol commit y1[16];
    pol commit x2[16];
    pol commit y2[16];
    pol commit x3[16];
    pol commit y3[16];

    pol commit s[16];
    pol commit q0[16];
    pol commit q1[16];
    pol commit q2[16];

    pol commit y2_clock;
    pol commit x3y3_clock;

    pol commit resultEq;

    resultEq * (1 - resultEq) = 0;

    // FEATURE:
    //      · Verify that the x1,x2 are different when adding different elliptic curve points (EQ1,EQ3,EQ4).

    // PRE:
    //      · x1,x2,y1,y2 are alias free for EQ[1..10]

    // In the first 16 clocks of 32-clock cycle we have: x2[0]-x1[0], x2[1]-x1[1], ..., x2[15]-x1[15]
    // In the last  16 clocks of 32-clock cycle we set all values to 0.
    pol xDeltaChunk = <%- clksel(['x2[0..15]',], 'Global.CLK32') %>
                    - <%- clksel(['x1[0..15]'], 'Global.CLK32', ' - ') %>;

    // Inverse of current xDeltaChunk. Used to verify that xDeltaChunk is ≠ 0, i.e., when x1[i] ≠ x2[i].
    // This inverse only needs to be calculated one time by cycle.
    pol commit xDeltaChunkInverse;

    // Intermediate pol to indicate that x1 is different from x2 in the current chunk.
    // IMPORTANT: xChunkDifferent == 1 ==> x1[i] ≠ x2[i]
    //            xChunkDifferent == 0 does not imply anything, x1[i] ≠ x2[i] or x1[i] == x2[i].
    // xChunkDifferent was binary, only when xDeltaChunkInverse === inv(xDeltaChunk), its value is 1.
    pol xChunkDifferent = xDeltaChunk * xDeltaChunkInverse;

    // Important, binary constraint
    xChunkDifferent * (1 - xChunkDifferent) = 0;

    // xDeltaChunk  xDeltaChunkInverse  xChunkDifferent
    // -----------  ------------------  -----------------------
    //       0             any          0 * any = 0            OK (A)
    //   x (≠ 0)           0            x * 0 = 0              OK (B)
    //   x (≠ 0)         inv(x)         x * inv(x) = 1         OK (C)
    //   x (≠ 0)      y ≠ {inv(x),0}    x * y = k (≠ 0,1)      FAILS (D)
    //
    // (A) and (C) are the standard cases, but (B) was introduced to avoid calculate the inverse when
    // it is not necessary. xChunkDifferent is well calculed because it's 1 only when x ≠ 0 and inverse
    // it's calculated.

    // xAreDifferent is used to indicate that in current clock we knows that x1 and x2 are different
    pol commit xAreDifferent;

    // Binary constraint
    xAreDifferent * (1 - xAreDifferent) = 0;

    // In first clock of 16-clock cycle, xAreDifferent should not be considered
    // Constraint to force next value of xAreDifferent

    xAreDifferent' = xAreDifferent * (1 - Global.CLK32[0] - Global.CLK32[16]) + xChunkDifferent;

    // xAreDifferent  CLK0+CLK16  xChunkDifferent  xAreDifferent'
    // -------------  ----------  ---------------  --------------
    //        0           0              0            0 OK
    //        0           0              1            1 OK
    //        0           1              0            1 OK
    //        0           1              1            1 OK
    //        1           0              0            1 OK
    //        1           0              1            2 FAILS (A)
    //        1           1              0            1 OK
    //        1           1              1            1 OK
    //
    // xChunkDifferent = 0 ==> (x2[i] - x1[i]) = 0
    // xChunkDifferent = 1 ==> (x2[i] - x1[i]) ≠ 0  ==> x1 and x2 are different
    // (A) forbidden, executor must control this situation, because expending an
    // unnecessary inverse.

    (xAreDifferent - selEq[1]) * Global.CLK32[16] = 0;

    // COST:   2 commit, 2 im, 0 constant, 4 constraints

    // FEATURE: x3,y3 range verification
    //
    // This feature is used on big finite field operations to verify that the result is alias-free, which means 
    // that the results are less than the prime number. Also, this feature is used in modular arithmetic to check 
    // that the result is less than a module.

    // valueLtPrime indicates whether we know that the value is smaller than the prime. When the current equation 
    // doesn't use this feature, valueLtPrime must be zero.
    pol commit valueLtPrime;

    // chunkLtPrime is a binary column that indicates that the current primeChunk is less than the current x3y3 chunk. 
    // When the current equation doesn't use this feature or the valueLtPrime is 1, chunkLtPrime must be zero.
    pol commit chunkLtPrime;

    // binary constraints
    valueLtPrime * (1 - valueLtPrime) = 0;
    chunkLtPrime * (1 - chunkLtPrime) = 0;

    // This constraint applies to the next value of valueLtPrime. At the beginning of each 16-clock cycle,
    // valueLtPrime is ignored because it refers to the previous value.
    valueLtPrime' = valueLtPrime * (1 - Global.CLK32[0] - Global.CLK32[16]) + chunkLtPrime;

    // This constraint is used to verify (and to enforce) that at the end of a 16-clock cycle, valueLtPrime is equal to 1.
    // This constraint is applied when one of selEq[1..6] equals 1.
    (valueLtPrime' - selEq[1] - selEq[2] - selEq[3] - selEq[4] - selEq[5] - selEq[6] - selEq[7] - selEq[8] - selEq[9] - selEq[10]) * (Global.CLK32[15] + Global.CLK32[31]) = 0;

    // Correctness of the y2_clock, x3_clock and y3_clock
    <%- clksel(['y2[15..0]','y2[15..0]'], 'Global.CLK32') %> - y2_clock = 0;
    <%- clksel(['x3[15..0]','y3[15..0]'], 'Global.CLK32') %> - x3y3_clock = 0;

    /****
    *
    * LATCH POLS: x1,y1,x2,y2,x3,y3,s,q0,q1,q2
    *
    *****/

    <%- latch('x1[0..15]','Global.CLK32[31]') %>

    <%- latch('y1[0..15]','Global.CLK32[31]') %>

    <%- latch('x2[0..15]','Global.CLK32[31]') %>

    <%- latch('y2[0..15]','Global.CLK32[31]') %>

    <%- latch('x3[0..15]','Global.CLK32[31]') %>

    <%- latch('y3[0..15]','Global.CLK32[31]') %>

    <%- latch('s[0..15]','Global.CLK32[31]') %>

    <%- latch('q0[0..15]','Global.CLK32[31]') %>

    <%- latch('q1[0..15]','Global.CLK32[31]') %>

    <%- latch('q2[0..15]','Global.CLK32[31]') %>

    //  RANGE CHECK x1,y1,x2,y2,s,q0,q1,q2

    pol commit hsc_x1y1, lsc_x1y1;
    pol commit hsc_x2y2, lsc_x2y2;
    pol commit hsc_sq0q1,  lsc_sq0q1;
    pol commit hsc_q1q2qh, lsc_q1q2qh;
    pol commit hsc_x3y3, lsc_x3y3;   
    
    // divide range check in two chunks of high significant chunk (hsc_xx) and less significant chunk (lsc_xx)
    // constrints to 
    
    <%- clksel(['x1[0..15]','y1[0..15]'], 'Global.CLK32') %> = hsc_x1y1 * 2**16 + lsc_x1y1;
    <%- clksel(['x2[0..15]','y2[0..15]'], 'Global.CLK32') %> = hsc_x2y2 * 2**16 + lsc_x2y2;
    <%- clksel(['x3[0..15]','y3[0..15]'], 'Global.CLK32') %> = hsc_x3y3 * 2**16 + lsc_x3y3;
    <%- clksel([ 's[0..15]','q0[0..14]','q1[0]'], 'Global.CLK32') %> = hsc_sq0q1 * 2**16 + lsc_sq0q1;
    <%- clksel(['q1[1..14]','q2[0..15]','q0[15]', 'q1[15]'], 'Global.CLK32') %> = hsc_q1q2qh * 2**16 + lsc_q1q2qh;

    pol commit hs_bit_delta, ls_bits_delta;
    pol commit primeChunk;

    pol constant PRIME_SECP256K1_CHUNKS; // cycle: 16 chunks x 16 bits of prime curve Secp256k1 from high significant chunk to less significant chunk
                                         // [0xFFFF:13, 0xFFFE, 0xFFFF, 0xFC2F]

    pol constant PRIME_BN254_CHUNKS;     // cycle: 16 chunks x 16 bits of prime curve BN254 from high significant chunk to less significant chunk
                                         // [0x3064, 0x4E72, 0xE131, 0xA029, 0xB850, 0x45B6, 0x8181, 0x585D, 
                                         //  0x9781, 0x6A91, 0x6871, 0xCA8D, 0x3C20, 0x8C16, 0xD87C, 0xFD47]...

    pol constant PRIME_BLS12381_CHUNKS;  // cycle: 16 chunks x 24 bits of prime curve BLS12-381 from high significant chunk to less significant chunk
                                         // [0x1A0111, 0xEA397F, 0xE69A4B, 0x1BA7B6, 0x434BAC, 0xD76477, 0x4B84F3, 0x8512BF, 
                                         //  0x6730D2, 0xA0F6B0, 0xF6241E, 0xABFFFE, 0xB153FF, 0xFFB9FE, 0xFFFFFF, 0xFFAAAB]...

    primeChunk = (selEq[1] + selEq[2]) * PRIME_SECP256K1_CHUNKS + 
                 (selEq[3] + selEq[4] + selEq[5]) * PRIME_BN254_CHUNKS + 
                 (selEq[8] + selEq[9] + selEq[10]) * PRIME_BLS12381_CHUNKS + 
                 (selEq[6] + selEq[7]) * y2_clock + 
                 (selEq[0] + selEq[11]) * x3y3_clock;

    // selEq[0] o selEq[11] => chunkLtPrime = 0, prime_chunk = x3y3_clock, hs_bit_delta = 0, ls_bits_delta = 0

    // delta = limit - x3y3_clock - chunkLtPrime ==> delta - limit + x3y3_clock + chunkLtPrime = 0
    // delta >= 0 ==> delta € [0, 2**24)

    (1 - valueLtPrime) * (hs_bit_delta * 2**23 + ls_bits_delta - primeChunk + x3y3_clock + chunkLtPrime) = 0;
        
    // check valueLtPrime is one at end of each 16 clocks for all operations that control limit of x3,y3.
    (valueLtPrime' - selEq[1] - selEq[2] - selEq[3] - selEq[4] - selEq[5] - selEq[6] - selEq[7] - selEq[8] - selEq[9] - selEq[10]) * (Global.CLK32[15] + Global.CLK32[31]) = 0;

    ls_bits_delta in Global.STEP;
    hs_bit_delta * (1 - hs_bit_delta) = 0;

    // check less significant chunks are 16 bits chunk
    lsc_x1y1 in Global.BYTE2;
    lsc_x2y2 in Global.BYTE2;
    lsc_x3y3 in Global.BYTE2;
    lsc_sq0q1  in Global.BYTE2;
    lsc_q1q2qh in Global.BYTE2;

    // BLS12-381 arith + modular 384 (no includes 256To384)
    pol arith384 = selEq[7] + selEq[8] + selEq[9] + selEq[10];

    // when operation no use fully (*) 384 bits, high part must be 0, because value must be < 2**16 
    hsc_x1y1 * (1 - arith384) = 0;
    hsc_x2y2 * (1 - arith384) = 0; 


    // s,q0,q1,q2 could be 24 bits ¿enought for arith384 ?
    hsc_sq0q1 * (1 - arith384) = 0;  


    // (*) in case of arith to prove 256TO384 no use fully 384 bits, because only op (x3) work with 384 bits.
    // 256TO384 don't use x3, for this reason not matter that it's 256 or 384 bits.
    hsc_x3y3 * (1 - arith384 - selEq[11]) = 0;  

    pol constant BYTE_2A_BIT14_SEL;
    pol constant BYTE_2A_BIT14;

    // BITS7_BYTE2: 7 bits + Global.BYTE: 8 bits + Global.BYTE_2A: 8 bits = 23 bits 
    // hsc_x1y1 has only 7 bits, the 8th bit was on hs_bit_x1y1
    // NOTE: done in this way because it's more cheaper 3 lookup in only one
    {hsc_x2y2, hsc_x3y3} in {Global.BYTE, Global.BYTE_2A};

    
    // TODO: review range checks of Qs
    // BYTE_2A_BIT14_SEL: 1 bit + Global.BYTE: 8 bits + BYTE_2A_BIT14: 14 bits = 23 bits 
    // low part: 16 + high part: 14 bits = 30 bits (REVIEW for 384 aritmetics)
    { Global.CLK32[29] + Global.CLK32[30] + Global.CLK32[31], hsc_sq0q1, hsc_q1q2qh} in {BYTE_2A_BIT14_SEL, Global.BYTE, BYTE_2A_BIT14};


    /*******
    *
    * EQ0: A(x1) * B(y1) + C(x2) = D (y2) * 2 ** 256 + op (y3)  # selEq[0] [256 bits]
    *
    *******/

    <%- equation('pol eq0_## =', 'x1*y1-p2_256*y2+x2-y3', {p2_256: 0x10000000000000000000000000000000000000000000000000000000000000000n}) %>

    /*******
    *
    * EQ1: s * x2 - s * x1 - y2 + y1 - p * (q0 - offset) = 0    # selEq[1] [SECP256K1, 256 bits]
    *
    *******/

    <%- equation('pol eq1_## =', 's*x2-s*x1-y2+y1-p*q0+p*offset', {p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
                                                                   offset:0x20000000000000000000000000000000000000000000000000000000000000000n}) %>

    /*******
    *
    * EQ2:  2 * s * y1 - 3 * x1 * x1 + p * (q0 - offset) = 0    # selEq[2] [SECP256K1, 256 bits]
    *
    *******/

    <%- equation('pol eq2_## =', 's*y1+s*y1-x1*x1-x1*x1-x1*x1+p*q0-p*offset', {p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
                                                                               offset:0x40000000000000000000000000000000000000000000000000000000000000000n}) %>

    /*******
    *
    * EQ3:  s * s - x1 - x2 - x3 - p * (q1 - offset) = 0        # selEq[1]+selEq[2] [SECP256K1, 256 bits]
    *
    *******/

    <%- equation('pol eq3_## =', 's*s-x1-x2-x3-p*q1+p*offset', {p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
                                                                offset:0x4n}) %>

    /*******
    *
    * EQ4:  s * x1 - s * x3 - y1 - y3 + p * (q2 - offset) = 0   # selEq[1]+selEq[2] [SECP256K1, 256 bits]
    *
    *******/

    <%- equation('pol eq4_## =', 's*x1-s*x3-y1-y3+p*q2-p*offset', {p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
                                                                   offset:0x20000000000000000000000000000000000000000000000000000000000000000n}) %>

    /*******
    *
    * EQ5:  x1 * x2 - y1 * y2 - x3 + p * (q1 - offset) = 0      # selEq[3] [BN254, 256 bits]
    *
    * EQ: x1 * x2 - y1 * y2
    * MAX: (2**256-1)**2 < 2**512
    * MIN: -((2**256-1)**2) < -(2**512)
    * Q1 NEGATIVE: ((2**256-1)**2) / P_BN254 < 2**259
    * Q1 OFFSET: 2**259
    * Q1 MAX + OFFSET: < 2**260 (+ 4 bits)
    * Q1 MIN + OFFSET: < 2**258 (+ 2 bits)
    *
    *******/

    <%- equation('pol eq5_## =', 'x1*x2-y1*y2-x3+p*q1-p*offset', {p: 21888242871839275222246405745257275088696311157297823662689037894645226208583n,
                                                                  offset:0x80000000000000000000000000000000000000000000000000000000000000000n}) %>

    /*******
    *
    * EQ6:  y1 * x2 + x1 * y2 - y3 - p * q2 = 0                  # selEq[3] [BN254, 256 bits]
    *
    * EQ: y1 * x2 + x1 * y2
    * MAX: 2*((2**256-1)**2) < 2**513
    * MIN: 0
    * Q1 MAX: < 2**260 (+ 4 bits)
    * Q1 MIN: 0
    ********/

    <%- equation('pol eq6_## =', 'y1*x2+x1*y2-y3-p*q2', {p: 21888242871839275222246405745257275088696311157297823662689037894645226208583n}) %>

    /*******
    *
    * EQ7:  x1 + x2 - x3 - p * q1 = 0                           # selEq[4] [BN254, 256 bits]
    *
    * EQ: x1 + x2
    * MAX: 2*(2**256-1) < 2**257
    * MIN: 0
    * QMAX: 2*(2**256-1) / P_BN254 = 10
    *
    *******/

    <%- equation('pol eq7_## =', 'x1+x2-x3-p*q1', {p: 21888242871839275222246405745257275088696311157297823662689037894645226208583n}) %>

    /*******
    *
    * EQ8:  y1 + y2 - y3 - p * q2 = 0                           # selEq[4] [BN254, 256 bits]
    *
    * EQ: y1 + y2
    * MAX: 2*(2**256-1) < 2**257
    * MIN: 0
    * QMAX: 2*(2**256-1) / P_BN254 = 10
    *
    *******/

    <%- equation('pol eq8_## =', 'y1+y2-y3-p*q2', {p: 21888242871839275222246405745257275088696311157297823662689037894645226208583n}) %>

    /*******
    *
    * EQ9:  x1 - x2 - x3 + p * (q1 - offset) = 0                # selEq[5] [BN254, 256 bits]
    *
    * EQ: x1 - x2
    * MAX: 2**256-1
    * MIN: -(2**256-1)
    * Q1 NEGATIVE: (2**256-1)/ P_BN254 = 5
    * Q1 OFFSET: 8 
    * Q1 MAX + OFFSET: 5 + 8 = 13
    * Q1 MIN + OFFSET: -5 + 8 = 3
    *
    *******/

    <%- equation('pol eq9_## =', 'x1-x2-x3+p*q1-p*offset', {p: 21888242871839275222246405745257275088696311157297823662689037894645226208583n,
                                                            offset: 8n}) %>

    /*******
    *
    * EQ10:  y1 - y2 - y3 + p * (q2 - offset) = 0               # selEq[5] [BN254, 256 bits]
    *
    * EQ: y1 - y2
    * MAX: 2**256-1
    * MIN: -(2**256-1)
    * Q1 NEGATIVE: (2**256-1)/ P_BN254 = 5
    * Q1 OFFSET: 8 
    * Q1 MAX + OFFSET: 5 + 8 = 13
    * Q1 MIN + OFFSET: -5 + 8 = 3
    *
    *******/

    <%- equation('pol eq10_## =', 'y1-y2-y3+p*q2-p*offset', {p: 21888242871839275222246405745257275088696311157297823662689037894645226208583n,
                                                             offset: 8n}) %>

    /*******
    *
    * EQ11:  A(x1) * B(y1) + C(x2) - op(y3) - q1 * D(y2) * 2**256 - q0 * D(y2) # selEq[6] [256 bits]
    *
    * EQ: x1 * y1 + x2
    * MAX: (2**256-1)**2+(2**256-1) < 2**512
    * MIN: 0
    * (WC) D2 = 1 ==> q1 * 2**256 + q0 ==> q1,q0 < 2**256 
    *
    *******/

    <%- equation('pol eq11_## =', 'x1*y1+x2-y3-q1*y2*powOfTwo-q0*y2', {powOfTwo: 0x10000000000000000000000000000000000000000000000000000000000000000n}) %>


    /*******
    *
    * EQ12:  A(x1) * B(y1) + C(x2) - op(y3) - q1 * D(y2) * 2**384 - q0 * D(y2) # selEq[7] [384 bits]
    *
    * EQ: x1 * y1 + x2
    * MAX: (2**384-1)**2+(2**384-1) < 2**768
    * MIN: 0
    * (WC) D2 = 1 ==> q1 * 2**384 + q0 ==> q1,q0 < 2**384 
    *
    *******/

    <%- equation('pol eq12_## =', 'x1*y1+x2-y3-q1*y2*powOfTwo-q0*y2', {powOfTwo: 0x1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000n}, {chunkBits: 24}) %>

    
    /*******
    *
    * EQ13:  x1 * x2 - y1 * y2 - x3 + p * (q1 - offset) = 0     # selEq[8] [BLS12-381, 384 bits]
    *
    * EQ: x1 * x2 - y1 * y2
    * MAX: (2**384-1)**2 < 2**768
    * MIN: -((2**384-1)**2) < -(2**768)
    * Q1 NEGATIVE: ((2**384-1)**2) / P_BLS12_381-381 < 2**388 
    * Q1 OFFSET: 2**388
    * Q1 MAX + OFFSET: < 2**389 (+ 5 bits)
    * Q1 MIN + OFFSET: < 2**387 (+ 3 bits)
    *
    *******/

    <%- equation('pol eq13_## =', 'x1*x2-y1*y2-x3+p*q1-p*offset', {p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn,
                                                                   offset:0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000n}, {chunkBits: 24}) %>

    /*******
    *
    * EQ14:  y1 * x2 + x1 * y2 - y3 - p * (q2 - offset) = 0     # selEq[8] [BLS12-381, 384 bits]
    *
    * EQ: y1 * x2 + x1 * y2
    * MAX: 2*((2**384-1)**2) < 2**769
    * MIN: 0
    * QMAX: 2*((2**384-1)**2) / P_BLS12_381 < 2**389 (+ 5 bits)
    *
    *******/

    <%- equation('pol eq14_## =', 'y1*x2+x1*y2-y3-p*q2', {p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn}, 
                                                         {chunkBits: 24}) %>

    /*******
    *
    * EQ15:  x1 + x2 - x3 - p * q1 = 0                    # selEq[9] [BLS12-381, 384 bits]
    *
    * EQ: x1 + x2
    * MAX: 2*(2**384-1) < 2**385
    * MIN: 0
    * QMAX: 2*(2**384-1) / P_BLS12_381 = 19
    *
    *******/

    <%- equation('pol eq15_## =', 'x1+x2-x3-p*q1', {p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn},
                                                   {chunkBits: 24}) %>

    /*******
    *
    * EQ16:  y1 + y2 - y3 - p * q2 = 0                    # selEq[9] [BLS12-381, 384 bits]
    *
    * EQ: y1 + y2
    * MAX: 2*(2**384-1) < 2**385
    * MIN: 0
    * QMAX: 2*(2**384-1) / P_BLS12_381 = 19
    *
    *******/

    <%- equation('pol eq16_## =', 'y1+y2-y3-p*q2', {p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn},
                                                   {chunkBits: 24}) %>

    /*******
    *
    * EQ17:  x1 - x2 - x3 + p * (q1 - offset) = 0               # selEq[10] [BLS12-381, 384 bits]
    *
    * EQ: x1 - x2
    * MAX: (2**384-1) < 2**384
    * MIN: -(2**384-1)
    * Q1 NEGATIVE: (2**384-1)/ P_BLS12-381 = 9
    * Q1 OFFSET: 16
    * Q1 MAX + OFFSET: 9 + 16 = 25
    * Q1 MIN + OFFSET: -9 + 16 = 7
    *
    *******/

    <%- equation('pol eq17_## =', 'x1-x2-x3+p*q1-p*offset', {p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn,
                                                            offset: 16n}, {chunkBits: 24}) %>

    /*******
    *
    * EQ18:  y1 - y2 - y3 + p * (q2 - offset) = 0               # selEq[10] [BLS12-381, 384 bits]
    *
    * EQ: y1 - y2
    * MAX: (2**384-1) < 2**384
    * MIN: -(2**384-1)
    * Q1 NEGATIVE: (2**384-1)/ P_BLS12-381 = 9
    * Q1 OFFSET: 16 (0x10)
    * Q1 MAX + OFFSET: 9 + 16 = 25
    * Q1 MIN + OFFSET: -9 + 16 = 7
    *
    *******/

    <%- equation('pol eq18_## =', 'y1-y2-y3+p*q2-p*offset', {p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn,
                                                             offset: 16n}, {chunkBits: 24}) %>
    
    /*******
    *
    * EQ19:  A(x1) + 2 ** 256 * B(y1)  = op (y3)                # selEq[11] [A,B: 256 bits / op: 384 bits]
    *
    *******/


    pol eq19_0 = x1[0] + 2**16 * x1[1] - y3[0];
    pol eq19_1 = 2**8 * x1[2] - y3[1];
    pol eq19_2 = x1[3] + 2**16 * x1[4] - y3[2];
    pol eq19_3 = 2**8 * x1[5] - y3[3];
    pol eq19_4 = x1[6] + 2**16 * x1[7] - y3[4];
    pol eq19_5 = 2**8 * x1[8] - y3[5];
    pol eq19_6 = x1[9] + 2**16 * x1[10] - y3[6];
    pol eq19_7 = 2**8 * x1[11] - y3[7];
    pol eq19_8 = x1[12] + 2**16 * x1[13] - y3[8];
    pol eq19_9 = 2**8 * x1[14] - y3[9];
    pol eq19_10 = x1[15] + 2**16 * y1[0] - y3[10];
    pol eq19_11 = 2**8 * y1[1] - y3[11];
    pol eq19_12 = y1[2] + 2**16 * y1[3] - y3[12];
    pol eq19_13 = 2**8 * y1[4] - y3[13];
    pol eq19_14 = y1[5] + 2**16 * y1[6] - y3[14];
    pol eq19_15 = 2**8 * y1[7] - y3[15];

    pol eq19_16 = 0;     // carry clean
    pol eq19_17 = 0;
    pol eq19_18 = 0;
    pol eq19_19 = y1[8];
    pol eq19_20 = y1[9];
    pol eq19_21 = y1[10];
    pol eq19_22 = y1[11];
    pol eq19_23 = y1[12];
    pol eq19_24 = y1[13];
    pol eq19_25 = y1[14];
    pol eq19_26 = y1[15];

    pol eq0 = <%- clksel(['eq0_[0..31]'], 'Global.CLK32') %>;
    pol eq1 = <%- clksel(['eq1_[0..31]'], 'Global.CLK32') %>;
    pol eq2 = <%- clksel(['eq2_[0..31]'], 'Global.CLK32') %>;
    pol eq3 = <%- clksel(['eq3_[0..31]'], 'Global.CLK32') %>;
    pol eq4 = <%- clksel(['eq4_[0..31]'], 'Global.CLK32') %>;
    pol eq5 = <%- clksel(['eq5_[0..31]'], 'Global.CLK32') %>;
    pol eq6 = <%- clksel(['eq6_[0..31]'], 'Global.CLK32') %>;
    pol eq7 = <%- clksel(['eq7_[0..31]'], 'Global.CLK32') %>;
    pol eq8 = <%- clksel(['eq8_[0..31]'], 'Global.CLK32') %>;
    pol eq9 = <%- clksel(['eq9_[0..31]'], 'Global.CLK32') %>;
    pol eq10 = <%- clksel(['eq10_[0..31]'], 'Global.CLK32') %>;
    pol eq11 = <%- clksel(['eq11_[0..31]'], 'Global.CLK32') %>;
    pol eq12 = <%- clksel(['eq12_[0..31]'], 'Global.CLK32') %>;
    pol eq13 = <%- clksel(['eq13_[0..31]'], 'Global.CLK32') %>;
    pol eq14 = <%- clksel(['eq14_[0..31]'], 'Global.CLK32') %>;
    pol eq15 = <%- clksel(['eq15_[0..31]'], 'Global.CLK32') %>;
    pol eq16 = <%- clksel(['eq16_[0..31]'], 'Global.CLK32') %>;
    pol eq17 = <%- clksel(['eq17_[0..31]'], 'Global.CLK32') %>;
    pol eq18 = <%- clksel(['eq18_[0..31]'], 'Global.CLK32') %>;
    pol eq19 = <%- clksel(['eq19_[0..26]'], 'Global.CLK32') %>;


    // Equation selectors. Must be binary, constant during the operation and operation-exclusive
    pol commit selEq[12];

    <%- latch(['selEq[0..11]'],'Global.CLK32[31]') %>
    <%- binary(['selEq[0..11]']) %>
    pol allSelEq = selEq[0] + selEq[1] + selEq[2] + selEq[3] + selEq[4] + selEq[5] + selEq[6] + selEq[7] + selEq[8] + selEq[9] + selEq[10] + selEq[11];

    <%- binary(['allSelEq']) %>

    pol commit ls_carry0, hs_carry0, ls_carry1, hs_carry1, carry2;

    pol carry0 = ls_carry0 + 2**23 * hs_carry0 - 2**28;
    pol carry1 = ls_carry1 + 2**23 * hs_carry1 - 2**28;

    carry0 * Global.CLK32[0] = 0;
    carry1 * Global.CLK32[0] = 0;
    carry2 * Global.CLK32[0] = 0;

    // TODO: review with 384
    ls_carry0 in Global.STEP;
    ls_carry1 in Global.STEP;
    carry2  in GL_SIGNED_22BITS;

    pol constant BITS7_C256; // [0:256...127:256,]
    pol constant BITS7_C32K; // [0:2**15...127:2**15]

    {hs_carry0, hs_carry1, hsc_x1y1} in {BITS7_C32K, BITS7_C256, Global.BYTE};

    selEq[0] * (eq0 + carry0) = selEq[0] * carry0' * 2**16;

    selEq[1] * (eq1 + carry0) = selEq[1] * carry0' * 2**16;
    selEq[2] * (eq2 + carry0) = selEq[2] * carry0' * 2**16;
    (selEq[1] + selEq[2]) * (eq3 + carry1) = (selEq[1] + selEq[2]) * carry1' * 2**16;
    (selEq[1] + selEq[2]) * (eq4 + carry2) = (selEq[1] + selEq[2]) * carry2' * 2**16;

    selEq[3] * (eq5 + carry0) = selEq[3] * carry0' * 2**16;
    selEq[3] * (eq6 + carry1) = selEq[3] * carry1' * 2**16;

    selEq[4] * (eq7 + carry0) = selEq[4] * carry0' * 2**16;
    selEq[4] * (eq8 + carry1) = selEq[4] * carry1' * 2**16;

    selEq[5] * (eq9 + carry0) = selEq[5] * carry0' * 2**16;
    selEq[5] * (eq10 + carry1) = selEq[5] * carry1' * 2**16;

    selEq[6] * (eq11 + carry0) = selEq[6] * carry0' * 2**16;

    selEq[7] * (eq12 + carry0) = selEq[7] * carry0' * 2**24;

    selEq[8] * (eq13 + carry0) = selEq[8] * carry0' * 2**24;
    selEq[8] * (eq14 + carry1) = selEq[8] * carry1' * 2**24;

    selEq[9] * (eq15 + carry0) = selEq[9] * carry0' * 2**24;
    selEq[9] * (eq16 + carry1) = selEq[9] * carry1' * 2**24;

    selEq[10] * (eq17 + carry0) = selEq[10] * carry0' * 2**24;
    selEq[10] * (eq18 + carry1) = selEq[10] * carry1' * 2**24;

    selEq[11] * (eq19 + carry0) = selEq[11] * carry0' * 2**24;
