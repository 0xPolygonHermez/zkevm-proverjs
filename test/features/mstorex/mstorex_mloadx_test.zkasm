CONST %MAX_CNT_MEM_ALIGN = 1000
CONST %MAX_CNT_STEPS = 64000
CONST %MAX_MEM_EXPANSION_BYTES = 0x3fffe0

VAR GLOBAL tmpA
VAR GLOBAL tmpB
VAR GLOBAL tmpC
VAR GLOBAL tmpD
VAR GLOBAL tmpE
VAR GLOBAL tmpSR
VAR GLOBAL tmpRR
VAR GLOBAL tmpRCX
VAR GLOBAL tmpHASHPOS
VAR GLOBAL tmpSP
VAR GLOBAL tmpPC
VAR GLOBAL tmpSTEP
VAR GLOBAL totSTEPS

start:

        STEP => A
        0 :ASSERT

        ; MEM:E    0x0000000000000000000000000000000000000000000000000000000000000000n 
        ; MEM:E+1  0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n 
        ; MEM:E+2  0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn 
        ; MEM:E+3  0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn 
        ; MEM:E+4  0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn 
        ; MEM:E+5  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn 


        ; TEST-1 (simple test)
                    
        0 => E,HASHPOS     :CALL(fillMemPattern)

        3*32+5 => E
        0xFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MLOADX)
        0xC5C6C7C8C9CAn :ASSERT
        $ => A        :MLOAD(tmpA)
        :CALL(check_registers)
        tmpE - C => E
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4FFFFFFFFFFFFCBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 1 => HASHPOS  ; setting test bit OK

        ; TEST-2 (between memory words)

        0 => E      :CALL(fillMemPattern)

        2*32+29 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MLOADX)
        0xBDBEBFC0C1C2n :ASSERT
        $ => A        :MLOAD(tmpA)
        :CALL(check_registers)
        tmpE - C => E
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCABCDEFn :MLOAD(MEM:E+2)
        0xFEDCBAC3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 2 => HASHPOS  ; setting test bit OK

        ; TEST-3 (relative offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MLOADX)
        0xA0A1A2A3A4A5n :ASSERT
        $ => A        :MLOAD(tmpA)
        :CALL(check_registers)
        tmpE - C => E
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)        

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xABCDEFFEDCBAA6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 4 => HASHPOS  ; setting test bit OK

        ; TEST-4 (32 bytes, offset > 0)

        0 => E      :CALL(fillMemPattern)

        2*32 + 18 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        32 => C
        :CALL(save_registers)
        :CALL(MLOADX)
        0xB2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1n :ASSERT
        $ => A        :MLOAD(tmpA)
        :CALL(check_registers)
        tmpE - C => E
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1102030405060708090A0B0C0D0E0n :MLOAD(MEM:E+2)
        0xF101112131415161718191A1B1C1D1E20210D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 8 => HASHPOS  ; setting test bit OK

        ; TEST-5 (0 bytes)

        0 => E      :CALL(fillMemPattern)

        2*32 + 18 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        0 => C
        :CALL(save_registers)
        :CALL(MLOADX)
        0 :ASSERT
        $ => A        :MLOAD(tmpA)
        :CALL(check_registers)
        tmpE - C => E
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 16 => HASHPOS  ; setting test bit OK

        ; TEST-6 (32 bytes, offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        32 => C
        :CALL(save_registers)
        :CALL(MLOADX)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :ASSERT
        $ => A        :MLOAD(tmpA)
        :CALL(check_registers)
        tmpE - C => E
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 32 => HASHPOS  ; setting test bit OK

        ; TEST-6 BIS (0 bytes, offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        0 => C
        :CALL(save_registers32)
        :CALL(MLOAD32)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :ASSERT
        $ => A        :MLOAD(tmpA)
        :CALL(check_registers)
        tmpE - 32 => E
        :CALL(save_registers32)
        :CALL(MSTORE32)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 512 => HASHPOS  ; setting test bit OK

        ; TEST-7 (high address)

        2**17-6 => E    :CALL(fillMemPattern)

        2**22-6*32+2*32+29 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MLOADX)
        0xBDBEBFC0C1C2n :ASSERT
        $ => A        :MLOAD(tmpA)
        :CALL(check_registers)
        tmpE - C => E
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        2**17-6 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCABCDEFn :MLOAD(MEM:E+2)
        0xFEDCBAC3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 64 => HASHPOS  ; setting test bit OK

        ; TEST-8 (1 byte, offset = 31)

        0 => E      :CALL(fillMemPattern)

        2*32+31 => E
        0x882030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        1 => C
        :CALL(save_registers)
        :CALL(MLOADX)
        0xBF :ASSERT
        $ => A        :MLOAD(tmpA)
        :CALL(check_registers)
        tmpE - C => E
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBE88n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 128 => HASHPOS  ; setting test bit OK

        ; TEST-9 (31 bytes, offset = 31)

        0 => E      :CALL(fillMemPattern)

        2*32+31 => E
        0x882030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        31 => C
        :CALL(save_registers)
        :CALL(MLOADX)
        0xBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDn :ASSERT
        $ => A        :MLOAD(tmpA)
        :CALL(check_registers)
        tmpE - C => E
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBE88n :MLOAD(MEM:E+2)
        0x2030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E202DEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 256 => HASHPOS,A  ; setting test bit OK

        ${dump(mem.totSTEPS)}

        0x3FF :ASSERT

        0x454E44 => A       :JMP(end)

fillMemPattern:

        0x0000000000000000000000000000000000000000000000000000000000000000n :MSTORE(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MSTORE(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MSTORE(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MSTORE(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MSTORE(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MSTORE(MEM:E+5), RETURN

save_registers32:
    E + 32      :MSTORE(tmpE),JMP(save_registers_common)
save_registers:
    E + C       :MSTORE(tmpE)
save_registers_common:
    A           :MSTORE(tmpA)
    B           :MSTORE(tmpB)
    C           :MSTORE(tmpC)
    D           :MSTORE(tmpD)
    SR          :MSTORE(tmpSR)
    RCX         :MSTORE(tmpRCX)
    HASHPOS     :MSTORE(tmpHASHPOS)
    SP          :MSTORE(tmpSP)
    PC          :MSTORE(tmpPC)
    STEP        :MSTORE(tmpSTEP),RETURN

check_registers:
    A           :MLOAD(tmpA)
    $ => A      :MLOAD(tmpSTEP)
    STEP - A - 4 => A
    B           :MLOAD(tmpB)
    $ => B      :MLOAD(totSTEPS)
    A + B       :MSTORE(totSTEPS)
    C           :MLOAD(tmpC)
    D           :MLOAD(tmpD)
    E           :MLOAD(tmpE)
    SR          :MLOAD(tmpSR)
    RCX         :MLOAD(tmpRCX)
    HASHPOS     :MLOAD(tmpHASHPOS)
    SP          :MLOAD(tmpSP)
    PC          :MLOAD(tmpPC), RETURN
        
INCLUDE "mstorex_mloadx.zkasm"

end:
        0x454E44 :ASSERT
        0 => A,B,C,D,E,CTX, SP, PC, GAS, SR

finalWait:
        ${beforeLast()}  : JMPN(finalWait)

                         : JMP(start)
opINVALID:
errorMLOADMSTORE:
outOfCountersStep:
outOfCountersMemalign:
failAssert:
        A + 1 :ASSERT
