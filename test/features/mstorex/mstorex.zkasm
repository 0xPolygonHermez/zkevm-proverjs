CONST %MAX_CNT_MEM_ALIGN = 1000
CONST %MAX_CNT_STEPS = 64000

VAR GLOBAL tmpA
VAR GLOBAL tmpB
VAR GLOBAL tmpC
VAR GLOBAL tmpD
VAR GLOBAL tmpE
VAR GLOBAL tmpSR
VAR GLOBAL tmpRR
VAR GLOBAL tmpRCX
VAR GLOBAL tmpHASHPOS
VAR GLOBAL tmpSP
VAR GLOBAL tmpPC
VAR GLOBAL tmpSTEP
VAR GLOBAL totSTEPS

start:

        STEP => A
        0 :ASSERT

        ; TEST-1 (simple test)
                    
        0 => E,HASHPOS     :CALL(fillMemPattern)

        3*32+5 => E
        0xFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4FFFFFFFFFFFFCBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 1 => HASHPOS  ; setting test bit OK

        ; TEST-2 (between memory words)

        0 => E      :CALL(fillMemPattern)

        2*32+29 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCABCDEFn :MLOAD(MEM:E+2)
        0xFEDCBAC3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 2 => HASHPOS  ; setting test bit OK

        ; TEST-3 (relative offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)        

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xABCDEFFEDCBAA6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 4 => HASHPOS  ; setting test bit OK

        ; TEST-4 (32 bytes, offset > 0)

        0 => E      :CALL(fillMemPattern)

        2*32 + 18 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        32 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1102030405060708090A0B0C0D0E0n :MLOAD(MEM:E+2)
        0xF101112131415161718191A1B1C1D1E20210D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 8 => HASHPOS  ; setting test bit OK

        ; TEST-5 (0 bytes)

        0 => E      :CALL(fillMemPattern)

        2*32 + 18 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        0 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 16 => HASHPOS  ; setting test bit OK

        ; TEST-6 (32 bytes, offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        32 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 32 => HASHPOS  ; setting test bit OK

        ; TEST-6 BIS (32 bytes, offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        0 => C
        :CALL(save_registers32)
        :CALL(MSTORE32)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 512 => HASHPOS  ; setting test bit OK

        ; TEST-7 (high address)

        2**17-6 => E    :CALL(fillMemPattern)

        2**22-6*32+2*32+29 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        2**17-6 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCABCDEFn :MLOAD(MEM:E+2)
        0xFEDCBAC3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 64 => HASHPOS  ; setting test bit OK

        ; TEST-8 (1 byte, offset = 31)

        0 => E      :CALL(fillMemPattern)

        2*32+31 => E
        0x882030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        1 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBE88n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 128 => HASHPOS  ; setting test bit OK

        ; TEST-9 (31 bytes, offset = 31)

        0 => E      :CALL(fillMemPattern)

        2*32+31 => E
        0x882030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        31 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBE88n :MLOAD(MEM:E+2)
        0x2030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E202DEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 256 => HASHPOS,A  ; setting test bit OK

        ${dump(mem.totSTEPS)}

        0x3FF :ASSERT

        0x454E44 => A       :JMP(end)

fillMemPattern:

        0x0000000000000000000000000000000000000000000000000000000000000000n :MSTORE(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MSTORE(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MSTORE(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MSTORE(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MSTORE(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MSTORE(MEM:E+5), RETURN

save_registers32:
    E + 32      :MSTORE(tmpE),JMP(save_registers_common)
save_registers:
    E + C       :MSTORE(tmpE)
save_registers_common:
    A           :MSTORE(tmpA)
    B           :MSTORE(tmpB)
    C           :MSTORE(tmpC)
    D           :MSTORE(tmpD)
    SR          :MSTORE(tmpSR)
    RCX         :MSTORE(tmpRCX)
    HASHPOS     :MSTORE(tmpHASHPOS)
    SP          :MSTORE(tmpSP)
    PC          :MSTORE(tmpPC)
    STEP        :MSTORE(tmpSTEP),RETURN

check_registers:
    A           :MLOAD(tmpA)
    $ => A      :MLOAD(tmpSTEP)
    STEP - A - 4 => A
    B           :MLOAD(tmpB)
    $ => B      :MLOAD(totSTEPS)
    A + B       :MSTORE(totSTEPS)
    C           :MLOAD(tmpC)
    D           :MLOAD(tmpD)
    E           :MLOAD(tmpE)
    SR          :MLOAD(tmpSR)
    RCX         :MLOAD(tmpRCX)
    HASHPOS     :MLOAD(tmpHASHPOS)
    SP          :MLOAD(tmpSP)
    PC          :MLOAD(tmpPC), RETURN
        
; ### MEM_ALIGN_RD
;
; M0=A, M1=B, V=op, Offset=C
;
; M0 = 256bit word read in position x of ZKEVM memory (32x EVM)
; M1 = 256bit word read in position x+1 of ZKEVM memory (32x+1 EVM)
; Offset = 0..31 bytes
; V = value of 256 bits
;
; ### MEM_ALIGN_WR
;
; M0=A, M1=B, V=op Offset=C, W0=D W1=E
; W0 = 256bit word to write position x of ZKEVM memory (32x EVM)
; W1 = 256bit word to write in position x+1 of ZKEVM memory (32x+1 EVM)

; @info save value to memory < 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @in C => length
; @out E => new offset


VAR GLOBAL tmpVarA_mstore
VAR GLOBAL tmpVarB_mstore
VAR GLOBAL tmpVarD_mstore
VAR GLOBAL tmpVarRR_mstore
VAR GLOBAL tmpVarLength_mstore
VAR GLOBAL tmpVarOffset_mstore
VAR GLOBAL tmpVar32BytesToStore_mstore

VAR GLOBAL bytesToStore

MSTOREX:  
        ; check if C == 32 then go to MSTORE32
        C - 32              :JMPZ(MSTORE32) ; in: [bytesToStore, E: offset] out: [E: new offset]

        ; store C with length (bytes), if length == 0 then nothing to do, go to __MSTOREX_end
        C                   :MSTORE(tmpVarLength_mstore),JMPZ(__MSTOREX_end)

        ; check step counters
        %MAX_CNT_STEPS - STEP - 40 :JMPN(outOfCountersStep)

        ; if length > 32 then ERROR
        32 - C              :JMPN(errorMLOADMSTORE)

        ; saving registers used
        A                   :MSTORE(tmpVarA_mstore)
        B                   :MSTORE(tmpVarB_mstore)
        D                   :MSTORE(tmpVarD_mstore)
        RR                  :MSTORE(tmpVarRR_mstore)
        
        ; A = offset in bytes of byte-address, no trust, if offset = 0 then go __MSTOREX_offset0 
        ; on __MSTOREX_offset0 must be verified value of A.
        $0{E % 32} => A     :MSTORE(tmpVarOffset_mstore), JMPZ(__MSTOREX_offset0)

        ; check MemAlign counters
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 3  :JMPN(outOfCountersMemalign)

        A => C              :JMPN(failAssert)    ; check A,C is positive 32 bits (A7..A1 = 0 because use $0)
        31 - C              :JMPN(failAssert)    ; check C < 32, if not MAP

        $0{E / 32} => RR    :JMPN(failAssert)    ; address (ASSERT RR is 32-bit value) 4G x 32 bytes = 128GB
        RR * 32 + C => A                         ; rebuild address to check that is same.
        E                   :ASSERT

        ;
        ; [STEP 1]: Obtain a copy of memory (as a backup) of a 32-byte word that will be partially overwritten.
        ;
        ; =========================== A (M0_addr) ========================######################### B (M0_addr+1) ########################
        ;                           :                                                              :
        ; |<-------- offset ------->======================================##########################  => B,oldvalue
        ;                           |<--------------------------- 32 bytes ----------------------->|
        ;

        $ => A      :MLOAD(MEM:RR)          ; M0
        $ => B      :MLOAD(MEM:RR+1)        ; M1
        ; C = offset, 
        ; B = 32 current bytes of memory
        $ => B      :MEM_ALIGN_RD ; read this 32 bytes with offset

        ;
        ; [STEP 2]: clear not used bytes of bytesToStore and oldvalue at same time. 
        ; A short-example with 3 bytes instead of 32. 
        ;
        ;   bytesToStore = ABCDEF   
        ;   B (memory backup) = 123456
        ;   length = 2
        ; 
        ; In this operation is cleared two things: 
        ;  - bytes of bytesToStore out of length: ABCDEF => AB0000 
        ;  - on bytes read from memory, clean where we put bytesToStore: 123456 => 003456 
        ;
        ;   bytesToStore =      AB0000           
        ;   B (memory backup) = 003456   
        ;
        ; Now we put bytesToStore and B side-by-side
        ;
        ;   bytesToStore  | B  =  ABCDEF123456
        ;                              â†“  write 0, with offset = 2
        ;   bytesToStore' | B' =  AB0000003456
        ;
        ; This operation is like a MEM_ALIGN_WR where M0 = bytesToStore, M1 = B, V = 0, offset = bytes = 2, W0 = bytesToStore', W1 = B'
        ;
        ;
        ; Graphical example:
        ;
        ; ******************* A (bytesToStore) ***************************======================================##########################
        ;                                     :                                                              :
        ; |<----------- length  ------------->0000000000000000000000000000000000000000000000000000000000000000
        ;                                     |<--------------------------- 32 bytes ----------------------->|
        ; ************************************0000000000000000000000000000                                   :                             => D
        ;                                                                 000000000000000000000000000000000000==########################## => E
        ;

        $ => A  :MLOAD(bytesToStore)
        ; B contains bytes of memory before write
        $ => C  :MLOAD(tmpVarLength_mstore)
        ${memAlignWR_W0(A,0,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,0,C)} => E ; no trust calculate W1
        0       :MEM_ALIGN_WR

        ; D    ************************************0000000000000000000000000000
        ; E    000000000000000000000000000000000000==##########################
        ; D+E  ************************************==########################## => tmpVar32BytesToStore_mstore
        ; D and E are  bit-disjoint, addition as logical-or

        D + E   :MSTORE(tmpVar32BytesToStore_mstore)

        ;
        ; [STEP 3]: store 32 bytes of this mix of bytes, first "length" bytes comes from bytesToStore, and others bytes comes current value
        ;           in memory, before write.
        ;
        ; =========================== A (M0_addr) ========================######################### B (M0_addr+1) ########################
        ;                           :                                                              :
        ; |<-------- offset ------->************************************==##########################
        ;                           |<--------------------------- 32 bytes ----------------------->|
        ;
        ; ==========================************************************==################################################################

        $ => A          :MLOAD(MEM:RR)       ;M0
        $ => B          :MLOAD(MEM:RR+1)     ;M1
        $ => C          :MLOAD(tmpVarOffset_mstore)

        ${memAlignWR_W0(A,mem.tmpVar32BytesToStore_mstore,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,mem.tmpVar32BytesToStore_mstore,C)} => E ; no trust calculate W1
        $               :MEM_ALIGN_WR,MLOAD(tmpVar32BytesToStore_mstore)

        ; write values on memory
        D               :MSTORE(MEM:RR)
        E               :MSTORE(MEM:RR+1)

        ; recalculate result on E as address + length. At this point E = 256-bit address * 32 + offset (C)
        ; pending add length
        RR * 32 + C => E

        ; restore C with length and add it to E
        $ => C          :MLOAD(tmpVarLength_mstore)
        E + C => E

        ; restore used registers and return
        $ => RR         :MLOAD(tmpVarRR_mstore)
        $ => A          :MLOAD(tmpVarA_mstore)
        $ => B          :MLOAD(tmpVarB_mstore)
        $ => D          :MLOAD(tmpVarD_mstore),RETURN

__MSTOREX_end:
        ; trivial case if length(C) == 0
        :RETURN

__MSTOREX_offset0:
        ; short path, offset == 0 (no trust)

        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        ; in this branch assume offset == 0, if offset != 0 ==> RR * 32 != E 
        $0{E / 32} => RR    :JMPN(failAssert)       ; address (ASSERT E is 32-bit value) 4G x 32 bytes = 128GB
        RR * 32 - E         :JMPNZ(failAssert)      ; 32 bits * 32 (5 bits) = 37 bits is secure for FF

        ; [STEP 1]: offset == 0, aligned read, memalign no needed.
        $ => B              :MLOAD(MEM:RR)          ; M0

        ; [STEP 2]: (see previous explanation)
        $ => A              :MLOAD(bytesToStore)
        ; B = current 32 bytes of memory
        ; C = length
        ${memAlignWR_W0(A,0,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,0,C)} => E ; no trust calculate W1
        0                   :MEM_ALIGN_WR

        ; [STEP 3]: trivial step, offset == 0 ==> aligned write, 
        ;           memalign no needed, directly store the logical-or of D and E
        D + E               :MSTORE(MEM:RR)

        ; Calculate output E = 256-bit address * 32 + length (C), offset = 0
        RR * 32 + C => E
    
        ; restore used registers, C contains original value (length)
        $ => RR             :MLOAD(tmpVarRR_mstore)
        $ => A              :MLOAD(tmpVarA_mstore)
        $ => B              :MLOAD(tmpVarB_mstore)
        $ => D              :MLOAD(tmpVarD_mstore),RETURN

; @info save value to memory 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @out E => new offset

MSTORE32:
        ; store C (length)
        A                   :MSTORE(tmpVarA_mstore)

        ; setting A as offset (no trust)
        $0{E & 0x1F} => A   :JMPZ(__MSTORE32_offset_0)

        ; at this point A != 0, but could be negative or positive 
        %MAX_CNT_STEPS - STEP - 30 :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        ; store registers will be used
        C                   :MSTORE(tmpVarLength_mstore)
        RR                  :MSTORE(tmpVarRR_mstore)    
        B                   :MSTORE(tmpVarB_mstore)
        D                   :MSTORE(tmpVarD_mstore)

        A => C              :JMPN(failAssert)        ; check C >= 0 (C7..C1 == 0 because use $0)
        31 - C              :JMPN(failAssert)        ; assert(C < 32)
        $0{E >> 5} => RR    :JMPN(failAssert)        ; RR must be a 32-bits positive value
        E => A
        RR * 32 + C         :ASSERT                  ; RR * 32 + C = E (use 38 bits secure)
                                                     ; validated offset and 256-bit address

        ; [STEP 1]: unnecessary because length = 32 => directly MemAlign 
        ; [STEP 2]: unnecessary we don't need to mix anything => directly MemAlign 

        ; [STEP 3]: with MemAlign calculate (verify) W0,W1 to write on memory
        $ => A              :MLOAD(MEM:RR)       ;M0
        $ => B              :MLOAD(MEM:RR+1)     ;M1
        ${memAlignWR_W0(A,mem.bytesToStore,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,mem.bytesToStore,C)} => E ; no trust calculate W1
        $                   :MEM_ALIGN_WR,MLOAD(bytesToStore)
        E                   :MSTORE(MEM:RR+1)
        D                   :MSTORE(MEM:RR)
        
        ; restore saved registers
        $ => A              :MLOAD(tmpVarA_mstore)
        $ => B              :MLOAD(tmpVarB_mstore)
        $ => D              :MLOAD(tmpVarD_mstore)

        ; Calculate output E = 256-bit address * 32 + offset (C) + length (32)
        RR * 32 + C + 32 => E    

        ; restore RR and C, this last because C is overwritten with offset
        $ => RR             :MLOAD(tmpVarRR_mstore)
        $ => C              :MLOAD(tmpVarLength_mstore), RETURN
        

__MSTORE32_offset_0:
        ; short path, offset == 0 (no trust)
        ; 32 bytes and offset == 0 ==> no mem align needed

        %MAX_CNT_STEPS - STEP - 10 :JMPN(outOfCountersStep)

        RR              :MSTORE(tmpVarRR_mstore)

        ${E >> 5} => RR :JMPN(failAssert)   ; RR must be a 32-bits positive value

        RR * 32 => A                        
        E               :ASSERT             ; RR * 32 = E (use 37 bits secure) check offset = 0

        ; if offset is 0, and length 32, directly store value on memory
        $ => A          :MLOAD(bytesToStore)

        ; stored on memory
        A               :MSTORE(MEM:RR)

        ; Calculate output E = 256-bit address * 32 + offset (0) + length (32)
        RR * 32 + 32 => E    

        ; restore saved registers and return
        $ => RR         :MLOAD(tmpVarRR_mstore)
        $ => A          :MLOAD(tmpVarA_mstore), RETURN

end:
        0x454E44 :ASSERT
        0 => A,B,C,D,E,CTX, SP, PC, GAS, SR

finalWait:
        ${beforeLast()}  : JMPN(finalWait)

                         : JMP(start)
opINVALID:
errorMLOADMSTORE:
outOfCountersStep:
outOfCountersMemalign:
failAssert:
        A + 1 :ASSERT
