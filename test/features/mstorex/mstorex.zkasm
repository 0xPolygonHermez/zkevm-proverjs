CONST %MAX_CNT_MEM_ALIGN = 1000
CONST %MAX_CNT_STEPS = 64000

VAR GLOBAL tmpA
VAR GLOBAL tmpB
VAR GLOBAL tmpC
VAR GLOBAL tmpD
VAR GLOBAL tmpE
VAR GLOBAL tmpSR
VAR GLOBAL tmpRR
VAR GLOBAL tmpRCX
VAR GLOBAL tmpHASHPOS
VAR GLOBAL tmpSP
VAR GLOBAL tmpPC
VAR GLOBAL tmpSTEP
VAR GLOBAL totSTEPS

start:

        STEP => A
        0 :ASSERT

        ; TEST-1 (simple test)
                    
        0 => E,HASHPOS     :CALL(fillMemPattern)

        3*32+5 => E
        0xFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4FFFFFFFFFFFFCBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 1 => HASHPOS  ; setting test bit OK

        ; TEST-2 (between memory words)

        0 => E      :CALL(fillMemPattern)

        2*32+29 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCABCDEFn :MLOAD(MEM:E+2)
        0xFEDCBAC3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 2 => HASHPOS  ; setting test bit OK

        ; TEST-3 (relative offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)        

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xABCDEFFEDCBAA6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 4 => HASHPOS  ; setting test bit OK

        ; TEST-4 (32 bytes, offset > 0)

        0 => E      :CALL(fillMemPattern)

        2*32 + 18 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        32 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1102030405060708090A0B0C0D0E0n :MLOAD(MEM:E+2)
        0xF101112131415161718191A1B1C1D1E20210D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 8 => HASHPOS  ; setting test bit OK

        ; TEST-5 (0 bytes)

        0 => E      :CALL(fillMemPattern)

        2*32 + 18 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        0 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 16 => HASHPOS  ; setting test bit OK

        ; TEST-6 (32 bytes, offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        32 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 32 => HASHPOS  ; setting test bit OK

        ; TEST-6 BIS (32 bytes, offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        0 => C
        :CALL(save_registers32)
        :CALL(MSTORE32)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 512 => HASHPOS  ; setting test bit OK

        ; TEST-7 (high address)

        2**17-6 => E    :CALL(fillMemPattern)

        2**22-6*32+2*32+29 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        2**17-6 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCABCDEFn :MLOAD(MEM:E+2)
        0xFEDCBAC3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 64 => HASHPOS  ; setting test bit OK

        ; TEST-8 (1 byte, offset = 31)

        0 => E      :CALL(fillMemPattern)

        2*32+31 => E
        0x882030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        1 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBE88n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 128 => HASHPOS  ; setting test bit OK

        ; TEST-9 (31 bytes, offset = 31)

        0 => E      :CALL(fillMemPattern)

        2*32+31 => E
        0x882030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(bytesToStore)
        31 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBE88n :MLOAD(MEM:E+2)
        0x2030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E202DEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 256 => HASHPOS,A  ; setting test bit OK

        ${dump(mem.totSTEPS)}

        0x3FF :ASSERT

        0x454E44 => A       :JMP(end)

fillMemPattern:

        0x0000000000000000000000000000000000000000000000000000000000000000n :MSTORE(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MSTORE(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MSTORE(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MSTORE(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MSTORE(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MSTORE(MEM:E+5), RETURN

save_registers32:
    E + 32      :MSTORE(tmpE),JMP(save_registers_common)
save_registers:
    E + C       :MSTORE(tmpE)
save_registers_common:
    A           :MSTORE(tmpA)
    B           :MSTORE(tmpB)
    C           :MSTORE(tmpC)
    D           :MSTORE(tmpD)
    SR          :MSTORE(tmpSR)
    RCX         :MSTORE(tmpRCX)
    HASHPOS     :MSTORE(tmpHASHPOS)
    SP          :MSTORE(tmpSP)
    PC          :MSTORE(tmpPC)
    STEP        :MSTORE(tmpSTEP),RETURN

check_registers:
    A           :MLOAD(tmpA)
    $ => A      :MLOAD(tmpSTEP)
    STEP - A - 4 => A
    B           :MLOAD(tmpB)
    $ => B      :MLOAD(totSTEPS)
    A + B       :MSTORE(totSTEPS)
    C           :MLOAD(tmpC)
    D           :MLOAD(tmpD)
    E           :MLOAD(tmpE)
    SR          :MLOAD(tmpSR)
    RCX         :MLOAD(tmpRCX)
    HASHPOS     :MLOAD(tmpHASHPOS)
    SP          :MLOAD(tmpSP)
    PC          :MLOAD(tmpPC), RETURN
        
; ### MEM_ALIGN_RD
;
; M0=A, M1=B, V=op, Offset=C
;
; M0 = 256bit word read in position x of ZKEVM memory (32x EVM)
; M1 = 256bit word read in position x+1 of ZKEVM memory (32x+1 EVM)
; Offset = 0..31 bytes
; V = value of 256 bits
;
; ### MEM_ALIGN_WR
;
; M0=A, M1=B, V=op Offset=C, W0=D W1=E
; W0 = 256bit word to write position x of ZKEVM memory (32x EVM)
; W1 = 256bit word to write in position x+1 of ZKEVM memory (32x+1 EVM)

; @info save value to memory < 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @in C => length
; @out E => new offset

CONST %MA_LEN_FACTOR = 128
CONST %MA_LEFT_ALIGN = 8192

VAR GLOBAL tmpVarA_mstore
VAR GLOBAL tmpVarB_mstore
VAR GLOBAL tmpVarD_mstore
VAR GLOBAL tmpVarRR_mstore
VAR GLOBAL tmpVarLength_mstore
VAR GLOBAL tmpVarOffset_mstore
VAR GLOBAL tmpVar32BytesToStore_mstore

VAR GLOBAL MSTOREX_Addr32
VAR GLOBAL MSTOREX_Offset32
VAR GLOBAL __MSTOREX_Offset

VAR GLOBAL bytesToStore

MSTORE32:
        ; check step counters
        %MAX_CNT_STEPS - STEP - 20              :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        A                           :SAVE(B,C,D,E,RR,RCX)
        32 => C

        E                           :MSTORE(MSTOREX_Offset)
        ; $BYTE{E % 32}
        ; $BITS5{E % 32}
        $0{E % 32} => RCX           :MSTORE(MSTOREX_Offset32),JMPZ(__MSTORE32_offset32_zero, __MSTORE32_addr32)

__MSTORE32_offset32_zero:
        $0{E / 32} => RR            :MSTORE(MSTOREX_Addr32)
        32 * RR                     :MLOAD(MSTOREX_Offset),JMPZ(__MSTORE_aligned)        
        $ => C                      :MLOAD(bytesToStore)
        C                           :MSTORE(MEM:RR)
        $ => A                      :RESTORE
        MSTOREX_Offset + 32 => E    :RETURN
        
MSTOREX:  
        ; check step counters
        %MAX_CNT_STEPS - STEP - 20              :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        C                       :JMPZ(__MSTOREX_end)
        ; really needed ? 
        ; 32 - C                :JMPN(failAssert)      

        A                       :SAVE(B,C,D,E,RR,RCX)

        ; $BYTE{E % 32}

        $0{E / 32} => RR          :JMPN(failAssert)
        ; RR = 32 bits positive value

    
        31 - $0{E % 32} => RCX,A  :F_MSTORE(__MSTOREX_byteOffset),JMPN(failAssert)
        ; A = 31 - byteOffset
        ; byteOffset < 32 (if not failAssert)

__MSTORE32_addr32:
        ; A = 31 - byteOffset
        ; 31 - E + 32 * RR === 31 - byteOffset ==> 32 * RR + byteOffset === E
        31 - E + 32 * RR        :ASSERT

        __MSTOREX_byteOffset + %MA_LEN_FACTOR * C + %MA_LEFT_ALIGN => C
        
        
        $ => A                  :MLOAD(MEM:RR)
        $ => B                  :MLOAD(MEM:RR+1)

        ${memAlignWR_W0(A,mem.bytesToStore,C)} => D    :MSTORE(MEM:RR)      ; no trust calculate W0
        ${memAlignWR_W1(B,mem.bytesToStore,C)} => E    :MSTORE(MEM:RR + 1)  ; no trust calculate W1

        $                       :MEM_ALIGN_WR,MLOAD(bytesToStore)
        $ => A                  :RESTORE
        E + C => E              :RETURN

__MSTORE_offset32_zero:
        $0{E / 32} => RR        :MSTORE(MSTOREX_Addr32)
        32 * RR                 :MLOAD(MSTOREX_Offset)
        C - 32                  :JMPZ(__MSTORE_aligned)        

        
        $ => A                  :MLOAD(MEM:RR)
        0 => B,E                

        C * %MA_LEN_FACTOR + %MA_LEFT_ALIGN => C
        ${memAlignWR_W0(A,mem.bytesToStore,C)} => D    :MSTORE(MEM:RR) ; no trust calculate W0

        $                       :MEM_ALIGN_WR,MLOAD(bytesToStore)
        $ => A                  :RESTORE
        MSTOREX_Offset + C => E :RETURN


__MSTORE_aligned:
        $ => C                  :MLOAD(bytesToStore)
        C                       :MSTORE(MEM:RR)
        $ => A                  :RESTORE
        MSTOREX_Offset + C => E :RETURN

        
__MSTOREX_end:
                                :RETURN


end:
        0x454E44 :ASSERT
        0 => A,B,C,D,E,CTX, SP, PC, GAS, SR

finalWait:
        ${beforeLast()}  : JMPN(finalWait)

                         : JMP(start)
opINVALID:
errorMLOADMSTORE:
outOfCountersStep:
outOfCountersMemalign:
failAssert:
        A + 1 :ASSERT
