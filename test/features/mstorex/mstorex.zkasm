VAR GLOBAL tmpA
VAR GLOBAL tmpB
VAR GLOBAL tmpC
VAR GLOBAL tmpD
VAR GLOBAL tmpE
VAR GLOBAL tmpSR
VAR GLOBAL tmpRR
VAR GLOBAL tmpRCX
VAR GLOBAL tmpHASHPOS
VAR GLOBAL tmpSP
VAR GLOBAL tmpPC
VAR GLOBAL tmpSTEP
VAR GLOBAL totSTEPS

start:

        STEP => A
        0 :ASSERT

        ; TEST-1 (simple test)
                    
        0 => E,HASHPOS     :CALL(fillMemPattern)

        3*32+5 => E
        0xFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000n :MSTORE(MSTOREX_bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4FFFFFFFFFFFFCBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 1 => HASHPOS  ; setting test bit OK

        ; TEST-2 (between memory words)

        0 => E      :CALL(fillMemPattern)

        2*32+29 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(MSTOREX_bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCABCDEFn :MLOAD(MEM:E+2)
        0xFEDCBAC3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 2 => HASHPOS  ; setting test bit OK

        ; TEST-3 (relative offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(MSTOREX_bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)        

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xABCDEFFEDCBAA6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 4 => HASHPOS  ; setting test bit OK

        ; TEST-4 (32 bytes, offset > 0)

        0 => E      :CALL(fillMemPattern)

        2*32 + 18 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(MSTOREX_bytesToStore)
        32 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1102030405060708090A0B0C0D0E0n :MLOAD(MEM:E+2)
        0xF101112131415161718191A1B1C1D1E20210D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 8 => HASHPOS  ; setting test bit OK

        ; TEST-5 (0 bytes)

        0 => E      :CALL(fillMemPattern)

        2*32 + 18 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(MSTOREX_bytesToStore)
        0 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 16 => HASHPOS  ; setting test bit OK

        ; TEST-6 (32 bytes, offset 0)

        0 => E      :CALL(fillMemPattern)

        2*32 => E
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(MSTOREX_bytesToStore)
        32 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0x102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 32 => HASHPOS  ; setting test bit OK

        ; TEST-7 (high address)

        2**17-6 => E    :CALL(fillMemPattern)

        2**22-6*32+2*32+29 => E
        0xABCDEFFEDCBA0000000000000000000000000000000000000000000000000000n :MSTORE(MSTOREX_bytesToStore)
        6 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        2**17-6 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCABCDEFn :MLOAD(MEM:E+2)
        0xFEDCBAC3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 64 => HASHPOS  ; setting test bit OK

        ; TEST-8 (1 byte, offset = 31)

        0 => E      :CALL(fillMemPattern)

        2*32+31 => E
        0x882030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(MSTOREX_bytesToStore)
        1 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBE88n :MLOAD(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 128 => HASHPOS  ; setting test bit OK

        ; TEST-9 (31 bytes, offset = 31)

        0 => E      :CALL(fillMemPattern)

        2*32+31 => E
        0x882030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E20210n :MSTORE(MSTOREX_bytesToStore)
        31 => C
        :CALL(save_registers)
        :CALL(MSTOREX)
        :CALL(check_registers)

        0 => E
        0x0000000000000000000000000000000000000000000000000000000000000000n :MLOAD(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MLOAD(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBE88n :MLOAD(MEM:E+2)
        0x2030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E202DEDFn :MLOAD(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MLOAD(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MLOAD(MEM:E+5)

        HASHPOS + 256 => HASHPOS,A  ; setting test bit OK

        ${dump(mem.totSTEPS)}

        0x1FF       :ASSERT

        0x454E44 => A
        A + 1 :ASSERT
        :JMP(end)

fillMemPattern:

        0x0000000000000000000000000000000000000000000000000000000000000000n :MSTORE(MEM:E)
        0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E2021n :MSTORE(MEM:E+1)
        0xA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFn :MSTORE(MEM:E+2)
        0xC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFn :MSTORE(MEM:E+3)
        0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEn :MSTORE(MEM:E+4)
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn :MSTORE(MEM:E+5), RETURN

save_registers:
    A           :MSTORE(tmpA)
    B           :MSTORE(tmpB)
    C           :MSTORE(tmpC)
    D           :MSTORE(tmpD)
    E + C       :MSTORE(tmpE)
    SR          :MSTORE(tmpSR)
    RCX         :MSTORE(tmpRCX)
    HASHPOS     :MSTORE(tmpHASHPOS)
    SP          :MSTORE(tmpSP)
    PC          :MSTORE(tmpPC)
    STEP        :MSTORE(tmpSTEP),RETURN

check_registers:
    A           :MLOAD(tmpA)
    $ => A      :MLOAD(tmpSTEP)
    STEP - A - 4 => A
    B           :MLOAD(tmpB)
    $ => B      :MLOAD(totSTEPS)
    A + B       :MSTORE(totSTEPS)
    C           :MLOAD(tmpC)
    D           :MLOAD(tmpD)
    E           :MLOAD(tmpE)
    SR          :MLOAD(tmpSR)
    RCX         :MLOAD(tmpRCX)
    HASHPOS     :MLOAD(tmpHASHPOS)
    SP          :MLOAD(tmpSP)
    PC          :MLOAD(tmpPC), RETURN
        
; ### MEM_ALIGN_RD
;
; M0=A, M1=B, V=op, Offset=C
;
; M0 = 256bit word read in position x of ZKEVM memory (32x EVM)
; M1 = 256bit word read in position x+1 of ZKEVM memory (32x+1 EVM)
; Offset = 0..31 bytes
; V = value of 256 bits
;
; ### MEM_ALIGN_WR
;
; M0=A, M1=B, V=op Offset=C, W0=D W1=E
; W0 = 256bit word to write position x of ZKEVM memory (32x EVM)
; W1 = 256bit word to write in position x+1 of ZKEVM memory (32x+1 EVM)

; @info save value to memory < 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @in C => length
; @out E => new offset


VAR GLOBAL MSTOREX_length
VAR GLOBAL MSTOREX_M0_addr
VAR GLOBAL MSTOREX_oldvalue
VAR GLOBAL MSTOREX_32BytesToStore
VAR GLOBAL MSTOREX_offset
VAR GLOBAL MSTOREX_bytesToStore

VAR GLOBAL MSTOREX_tmpA
VAR GLOBAL MSTOREX_tmpB
VAR GLOBAL MSTOREX_tmpC
VAR GLOBAL MSTOREX_tmpD
VAR GLOBAL MSTOREX_tmpRR

ERROR:
        A + 1 :ASSERT
MSTOREX:
        C - 32              :JMPZ(MSTOREX32)
                            
        C                   :MSTORE(MSTOREX_length),JMPZ(MSTOREX_END)
        32 - C              :JMPN(ERROR)

        A                   :MSTORE(MSTOREX_tmpA)
        B                   :MSTORE(MSTOREX_tmpB)
        D                   :MSTORE(MSTOREX_tmpD)
        RR                  :MSTORE(MSTOREX_tmpRR)
        
        $0{E % 32} => A     :MSTORE(MSTOREX_offset), JMPZ(MSTOREX_OFFSET0)
        A => C              :JMPN(ERROR)    ; check A,C is positive
        31 - C              :JMPN(ERROR)    ; check C < 32

        $0{E / 32} => RR    :MSTORE(MSTOREX_M0_addr), JMPN(ERROR)    ; address (ASSERT E is 32-bit value) 4G x 32 bytes = 128GB
        RR * 32 + C - E     :JMPNZ(ERROR)                            ; 32 bits * 32 (5 bits) = 37 bits is secure for FF

        ;
        ; STEP ONE: Obtain a copy of memory (as a backup) of a 32-byte word that will be partially overwritten.
        ;
        ; =========================== A (M0_addr) ========================######################### B (M0_addr+1) ########################
        ;                           :                                                              :
        ; |<-------- offset ------->======================================##########################  => B,oldvalue
        ;                           |<--------------------------- 32 bytes ----------------------->|
        ;

        ;
        ; STEP ONE: Obtain a copy of memory (as a backup) of a 32-byte word that will be partially overwritten.
        ;
        ; =========================== A (M0_addr) ========================######################### B (M0_addr+1) ########################
        ;                           :                                                              :
        ; |<-------- offset ------->======================================##########################  => B,oldvalue
        ;                           |<--------------------------- 32 bytes ----------------------->|
        ;

        ; C = offset
        $ => A      :MLOAD(MEM:RR)          ; M0
        $ => B      :MLOAD(MEM:RR+1)        ; M1
        $ => B      :MEM_ALIGN_RD ; storing this copy in MSTOREX_oldvalue

        ;
        ; STEP TWO: clear not used bytes of bytesToStore and oldvalue at same time. 
        ; A short-example with 3 bytes instead of 32. 
        ;
        ;   bytesToStore = ABCDEF   
        ;   B (memory backup) = 123456
        ;   length = 2
        ; 
        ; In this operation is cleared two things: 
        ;  - bytes of bytesToStore out of length: ABCDEF => AB0000 
        ;  - on bytes read from memory, clean where we put bytesToStore: 123456 => 003456 
        ;
        ;   bytesToStore =      AB0000           
        ;   B (memory backup) = 003456   
        ;
        ; Now we put bytesToStore and B side-by-side
        ;
        ;   bytesToStore  | B  =  ABCDEF123456
        ;                              â†“  write 0, with offset = 2
        ;   bytesToStore' | B' =  AB0000003456
        ;
        ; This operation is like a MEM_ALIGN_WR where M0 = bytesToStore, M1 = B, V = 0, offset = bytes = 2, W0 = bytesToStore', W1 = B'
        ;
        ;
        ; Graphical example:
        ;
        ; ******************* A (bytesToStore) ***************************======================================##########################
        ;                                     :                                                              :
        ; |<----------- length  ------------->0000000000000000000000000000000000000000000000000000000000000000
        ;                                     |<--------------------------- 32 bytes ----------------------->|
        ; ************************************0000000000000000000000000000                                   :                             => D
        ;                                                                 000000000000000000000000000000000000==########################## => E
        ;

        $ => A  :MLOAD(MSTOREX_bytesToStore)
        $ => C  :MLOAD(MSTOREX_length)
        ${memAlignWR_W0(A,0,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,0,C)} => E ; no trust calculate W1
        0       :MEM_ALIGN_WR

        ; D    ************************************0000000000000000000000000000
        ; E    000000000000000000000000000000000000==##########################
        ; D+E  ************************************==########################## => MSTOREX_32BytesToStore

        D + E   :MSTORE(MSTOREX_32BytesToStore)

        ;
        ; STEP THREE: store 32 bytes of this mix of bytes, first "length" bytes comes from bytesToStore, and others bytes comes from oldvalue,
        ;             current value in memory.
        ;
        ; =========================== A (M0_addr) ========================######################### B (M0_addr+1) ########################
        ;                           :                                                              :
        ; |<-------- offset ------->************************************==##########################
        ;                           |<--------------------------- 32 bytes ----------------------->|
        ;
        ; ==========================************************************==################################################################

        $ => A  :MLOAD(MEM:RR)       ;M0
        $ => B  :MLOAD(MEM:RR+1)     ;M1
        $ => C  :MLOAD(MSTOREX_offset)

        ${memAlignWR_W0(A,mem.MSTOREX_32BytesToStore,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,mem.MSTOREX_32BytesToStore,C)} => E ; no trust calculate W1
        $       :MEM_ALIGN_WR,MLOAD(MSTOREX_32BytesToStore)

MSTOREX_STORE:
        D               :MSTORE(MEM:RR)
        E               :MSTORE(MEM:RR+1)

        RR * 32 + C => E
        $ => C          :MLOAD(MSTOREX_length)
        E + C => E

        $ => RR         :MLOAD(MSTOREX_tmpRR)
        $ => A          :MLOAD(MSTOREX_tmpA)
        $ => B          :MLOAD(MSTOREX_tmpB)
        $ => D          :MLOAD(MSTOREX_tmpD),RETURN

MSTOREX_OFFSET0:

        $0{E / 32} => RR    :JMPN(ERROR)      ; address (ASSERT E is 32-bit value) 4G x 32 bytes = 128GB
        RR * 32 - E         :JMPNZ(ERROR)     ; 32 bits * 32 (5 bits) = 37 bits is secure for FF

        $ => B              :MLOAD(MEM:RR)          ; M0

        $ => A              :MLOAD(MSTOREX_bytesToStore)
        ${memAlignWR_W0(A,0,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,0,C)} => E ; no trust calculate W1
        0                   :MEM_ALIGN_WR
        D + E               :MSTORE(MEM:RR)

        RR * 32 + C => E
        $ => RR             :MLOAD(MSTOREX_tmpRR)
        $ => A              :MLOAD(MSTOREX_tmpA)
        $ => B              :MLOAD(MSTOREX_tmpB)
        $ => D              :MLOAD(MSTOREX_tmpD),RETURN

MSTOREX32:
        $0{E & 0x1F} => C   :JMPZ(MSTOREX32_OFFSET0)

MSTOREX32_OFFSET_NZ:
        RR                  :MSTORE(MSTOREX_tmpRR)    
        A                   :MSTORE(MSTOREX_tmpA)
        B                   :MSTORE(MSTOREX_tmpB)
        D                   :MSTORE(MSTOREX_tmpD)

        C                   :JMPN(ERROR)            
        31 - C              :JMPN(ERROR)        ; assert(C < 32)
        $0{E >> 5} => RR    :JMPN(ERROR)        ; RR must be a 32-bits positive value
        RR * 32 + C - E     :JMPNZ(ERROR)       ; RR * 32 + C = E (use 38 bits secure) check offset = 0

        $ => A              :MLOAD(MEM:RR)       ;M0
        $ => B              :MLOAD(MEM:RR+1)     ;M1
        ${memAlignWR_W0(A,mem.MSTOREX_bytesToStore,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,mem.MSTOREX_bytesToStore,C)} => E ; no trust calculate W1
        $                   :MEM_ALIGN_WR,MLOAD(MSTOREX_bytesToStore)
        E                   :MSTORE(MEM:RR+1)
        D                   :MSTORE(MEM:RR)
        

        $ => A              :MLOAD(MSTOREX_tmpA)
        $ => B              :MLOAD(MSTOREX_tmpB)
        $ => D              :MLOAD(MSTOREX_tmpD)
        RR * 32 + C + 32 => E    
        $ => RR             :MLOAD(MSTOREX_tmpRR)
        32 => C             :RETURN
        

MSTOREX32_OFFSET0:
        RR              :MSTORE(MSTOREX_tmpRR)
        ${E >> 5} => RR :JMPN(ERROR)            ; RR must be a 32-bits positive value
        RR * 32 - E     :JMPNZ(ERROR)           ; RR * 32 = E (use 37 bits secure) check offset = 0

        ; if offset is 0, and length 32, directly store value on memory
        $ => C          :MLOAD(MSTOREX_bytesToStore)
        C               :MSTORE(MEM:RR)
        RR * 32 + 32 => E    
        $ => RR         :MLOAD(MSTOREX_tmpRR)
        32 => C         :RETURN


MSTOREX_END:
        :RETURN


end:
        0x454E44 :ASSERT
        ${dumpRegs()}
        0 => A,B,C,D,E,CTX, SP, PC, GAS, SR

finalWait:
        ${beforeLast()}  : JMPN(finalWait)

                         : JMP(start)
opINVALID: