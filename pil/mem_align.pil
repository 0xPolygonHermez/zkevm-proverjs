include "global.pil";
namespace MemAlign(%N);

    /*
    * OPERATIONS
    *
    *  (m0,m1,D) => v
    *  (m0,m1,D,v) => (w0, w1)
    *
    *  @m0 = addr   @m1 = addr + 8 (ethereum)
    *
    *  Ethereum => BigEndian
    *  m0[1],m0[0],m1[1],m1[0]
    *
    *  inM (8 bits, 8 steps)
    */

    // 8 bytes of M0, M1 ordered from HSB to LSB (7, 6, 5, ... == M[1].3, M[1].2, M[1].1, M[1].0, M[0].3, ..)
    pol commit inM[2];

    // 8 bytes of V
    pol commit inV;

    // write 8 bytes (64 bits)
    pol commit wr64;

    // write 1 byte (8 bits), its special case because need to ignore
    // the rest of bytes, only LSB of V was stored (on w0 with offset)
    pol commit wr8;

    pol commit m0[2];
    pol commit m1[2];
    pol commit w0[2];
    pol commit w1[2];
    pol commit v[2];

    // when m1 is "active", means aligned with inV
    // also when wr8 = 1, used to indicate when store the LSB
    pol commit selM1;

    // factors to build V[] in correct way, because order of V bytes
    // changes according the offset and wr8
    pol commit factorV[2];

    pol commit offset;

    // BYTE_C1024 = 0 (x1024), 1 (x1024), ... , 254 (x1024), 255 (x1024), 0 (x1024), 1 (x1024), ...
    pol constant BYTE_C1024; // [0:1024..255:1024]

    // FACTOR was same for all combinations of offset, wr8, wr64 is a f(step)
    // FACTOR[1] = 2**24, 2**16, 2**8, 1, 0 (x4)
    // FACTOR[0] = 0 (x4), 2**24, 2**16, 2**8, 1
    pol constant FACTOR[2];

    // FACTOR change according the combinations of offset, wr8, wr64 and step.
    pol constant FACTORV[2];

    // STEP8
    //    0 -  255  WR64 = 0 WR8 = 0
    //  256 -  511  WR64 = 0 WR8 = 0
    //  512 -  767  WR64 = 1 WR8 = 0
    //  768 - 1023  WR64 = 0 WR8 = 1
    pol constant WR64; // [0:512,1:256:0:256]
    pol constant WR8;   // [0:768,1:256]

    // OFFSET = 0 (x32), 1 (x32), ... , 31 (x32), 32 (x32), 0 (x32), 1 (x32), ...
    pol constant OFFSET; // [0:32..31:32]

    pol constant SELM1;

    pol RESET = Global.CLK8[0];

    //              RangeCheck                  Latch   Clock
    // factorV      Plookup (FACTORV)           no      yes
    // wr64         Plookup (WR64)              yes     no
    // wr8          Plookup (WR8)               yes     no
    // offset       Plookup (OFFSET)            yes     no
    // inV          RangeCheck (BYTE_C4096)     no      yes
    // inM[0..1]    RangeCheck (BYTE2A,BYTE2)   no      yes
    // m0[0..1]     Built                       no      yes
    // m1[0..1]     Built                       no      yes
    // w0[0..1]     Built                       no      yes
    // w1[0..1]     Built                       no      yes
    // v[0..1]      Built                       no      yes
    // selM1        Plookup (SELM1)             no      yes

    // Latchs
    (1 - RESET) * wr64' = (1 - RESET) * wr64;
    (1 - RESET) * offset' = (1 - RESET) * offset;
    (1 - RESET) * wr8' = (1 - RESET) * wr8;

    pol commit resultRd;
    pol commit resultWr8;
    pol commit resultWr64;


    (1 - RESET) * resultRd = 0;
    (1 - RESET) * resultWr8 = 0;
    (1 - RESET) * resultWr64 = 0;

    resultRd * (1 - resultRd) = 0;
    resultWr8 * (1 - resultWr8) = 0;
    resultWr64 * (1 - resultWr64) = 0;

    (1 - wr8) * resultWr8 = 0;
    (1 - wr64) * resultWr64 = 0;
    (wr8 + wr64) * resultRd = 0;

    // RangeCheck
    {inM[1], inM[0]} in {Global.BYTE_2A, Global.BYTE};

    // Plookup
    {
        Global.STEP8, offset', wr64', wr8', selM1, inV,
        factorV[0], factorV[1]
    } in {
        Global.STEP8, OFFSET, WR64, WR8, SELM1, BYTE_C1024,
        FACTORV[0], FACTORV[1]
    };

    m0[0]' = (1-RESET) * m0[0] + FACTOR[0] * inM[0];
    m0[1]' = (1-RESET) * m0[1] + FACTOR[1] * inM[0];

    m1[0]' = (1-RESET) * m1[0] + FACTOR[0] * inM[1];
    m1[1]' = (1-RESET) * m1[1] + FACTOR[1] * inM[1];

    // selW0 contains data to be store in w0, must be 0 in "reading mode"
    // in "writting mode", in particular with wr8 only on byte must be
    // stored, for this reason use selM1 that was active only one clock (in wr8 mode)
    pol selW0 = (1 - selM1) * wr256' + selM1 * wr8';

    // selW1 contains data to be store in w1, must be 0 in "reading mode"
    pol selW1 = selM1 * wr256';

    // NOTE: when wr8 = 1 implies wr256 = 0, check in this situations where use selM1
    // to verify that non exists collateral effects
    //
    // pol selW0 = selM1 (because wr256 = 0 and wr8 = 1)
    //
    // selM1 used in pol _inM, but _inM is only used on dataV
    // pol dataV = (1 - wr256' - wr8') * _inM + (wr256' + wr8') * inV;
    // pol dataV = inV (because wr256 = 0 and wr8 = 1)
    //
    // CONCLUSION: it's safe reuse selM1 to indicate when store byte

    // data to "write" on w, if current byte must be override by V contains inV
    // if not contains inM "in reading mode" must be 0.
    pol dataW0 = (wr8' + wr256') * inM[0] + selW0 * (inV - inM[0]);
    pol dataW1 = (wr8' + wr256') * inM[1] + selW1 * (inV - inM[1]);

    w0[0]' = (1-RESET) * w0[0] + FACTOR[0] * dataW0;
    w0[1]' = (1-RESET) * w0[1] + FACTOR[1] * dataW0;

    w1[0]' = (1-RESET) * w1[0] + FACTOR[0] * dataW1;
    w1[1]' = (1-RESET) * w1[1] + FACTOR[1] * dataW1;

    // _inM contains "active" value of inM
    pol _inM = (1 - selM1) * inM[0] + selM1 * inM[1];

    // contains data to store in V, could be one of inM if was reading or inV if was writting
    pol dataV = (1 - wr256' - wr8') * _inM + (wr256' + wr8') * inV;

    // factorV = f(STEP, offset, wr8)
    v[0]' = (1-RESET) * v[0] + factorV[0] * dataV;
    v[1]' = (1-RESET) * v[1] + factorV[1] * dataV;

