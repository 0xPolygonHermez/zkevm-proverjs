include "config.pil";
include "global.pil";
include "rom.pil";
include "mem_align.pil";
include "arith.pil";
include "binary.pil";
include "padding_kk.pil";
include "mem.pil";

namespace Main(%N);

///////////
// Definitions
///////////

    /////// State Polynomials
    pol commit A0, A1;
    pol commit B0, B1;
    pol commit C0, C1;
    pol commit D0, D1;
    pol commit E0, E1;


    pol commit CTX;                    // Call Cntext
    pol commit SP;                     // Stack Pointer
    pol commit PC;                     // EVM Program counter
    pol commit GAS;
    pol commit zkPC;                   // Program Counter of current micro instruction
    pol commit RR;                     // Micro code return address (subroutines)
    pol commit HASHPOS;
    pol commit RCX;

    ///////  Instruction related polynomials
    pol commit CONST1, CONST0;
    pol commit FREE1, FREE0;
    pol commit inA, inB, inC, inROTL_C, inD, inE, inFREE, inCTX, inSP, inPC, inGAS, inSTEP, inRR, inHASHPOS, inRCX;
    pol commit setA, setB, setC, setD, setE, setCTX, setSP, setPC, setGAS, setRR, setHASHPOS, setRCX;
    pol commit JMP, JMPN, JMPC, JMPZ, offset;
    pol commit incStack;
    pol commit isStack;
    pol commit isMem;
    pol commit ind, indRR;
    pol commit useCTX;
    pol commit carry;

    // operations
    pol commit mOp, mWR;
    pol commit arith;
    pol commit memAlignRD, memAlignWR, memAlignWR8;
    pol commit hashK, hashK1, hashKLen, hashKDigest;
    pol commit bin;
    pol commit binOpcode;
    pol commit assert;
    pol commit repeat, call, return;

    ///////  Intermediary commit polynomials
    pol commit isNeg;

    /// Counters
    pol commit cntArith, cntBinary, cntMemAlign, cntKeccakF;
    pol commit inCntArith, inCntBinary, inCntMemAlign, inCntKeccakF;
    pol commit incCounter;

///////////
// Intermediary calculations and checks
///////////


    /////// op
    pol op0 =
        A0 * inA +
        B0 * inB +
        C0 * inC +
        C1 * inROTL_C +
        D0 * inD +
        E0 * inE +
        FREE0 * inFREE +
        CTX * inCTX +
        SP * inSP +
        PC * inPC +
        GAS * inGAS +
        Global.STEP * inSTEP +
        RR * inRR +
        HASHPOS * inHASHPOS +
        cntArith * inCntArith +
        cntBinary * inCntBinary +
        cntMemAlign * inCntMemAlign +
        cntKeccakF * inCntKeccakF +
        RCX * inRCX +
        CONST0;

    pol op1 =
        A1 * inA +
        B1 * inB +
        C1 * inC +
        C0 * inROTL_C +
        D1 * inD +
        E1 * inE +
        FREE1 * inFREE +
        CONST1;

    /////// addr

    /*

        ctxBase = CTX * 0x040000   ctxSize = 256K addresses * 32 bytes (256 bits) = 8MiB

        Memory Region                    Size   isMem  isStack   Content
        ctxBase + [0x000000 - 0x00FFFF]   2MiB      0        0   Context specific variables
        ctxBase + [0x010000 - 0x000000]   2MiB      0        1   EVM Stack
        ctxBase + [0x020000 - 0x03FFFF]   4MiB      1        0   EVM Memory

    */

    pol addrRel = ind*E0 + indRR*RR + offset;
    pol addr = useCTX*CTX*2**18 + isStack*2**16 + isStack*SP + isMem*2**17+ addrRel;

    /////// isNeg

    pol commit lJmpnCondValue;
    pol jmpnCondValue = JMPN*(isNeg*2**32 + op0);
    isNeg * (1 - isNeg) = 0;

    lJmpnCondValue in Global.STEP;

    pol commit hJmpnCondValueBit[9];

    hJmpnCondValueBit[8] * (1-hJmpnCondValueBit[8]) = 0;
    hJmpnCondValueBit[7] * (1-hJmpnCondValueBit[7]) = 0;
    hJmpnCondValueBit[6] * (1-hJmpnCondValueBit[6]) = 0;
    hJmpnCondValueBit[5] * (1-hJmpnCondValueBit[5]) = 0;
    hJmpnCondValueBit[4] * (1-hJmpnCondValueBit[4]) = 0;
    hJmpnCondValueBit[3] * (1-hJmpnCondValueBit[3]) = 0;
    hJmpnCondValueBit[2] * (1-hJmpnCondValueBit[2]) = 0;
    hJmpnCondValueBit[1] * (1-hJmpnCondValueBit[1]) = 0;
    hJmpnCondValueBit[0] * (1-hJmpnCondValueBit[0]) = 0;

    jmpnCondValue = 2**31*hJmpnCondValueBit[8] + 2**30*hJmpnCondValueBit[7] + 2**29*hJmpnCondValueBit[6] + 2**28*hJmpnCondValueBit[5] +
                    2**27*hJmpnCondValueBit[4] + 2**26*hJmpnCondValueBit[3] + 2**25*hJmpnCondValueBit[2] + 2**24*hJmpnCondValueBit[1] +
                    2**23*hJmpnCondValueBit[0] + lJmpnCondValue;


    /// RCX check zero
    pol commit RCXInv;
    pol RCXIsZero = 1 - RCX*RCXInv;
    RCXIsZero*RCX = 0;

    /// op0 check zero
    pol commit op0Inv;
    pol op0IsZero = 1 - op0*op0Inv;
    op0IsZero*op0 = 0;

///////////
// Calculate New State
///////////

    A0' = setA * (op0 - A0) + A0;
    A1' = setA * (op1 - A1) + A1;

    B0' = setB * (op0 - B0) + B0;
    B1' = setB * (op1 - B1) + B1;

    C0' = setC * (op0 - C0) + C0;
    C1' = setC * (op1 - C1) + C1;

    D0' = setD * (op0 - D0) + D0;
    D1' = setD * (op1 - D1) + D1;

    E0' = setE * (op0 - E0) + E0;
    E1' = setE * (op1 - E1) + E1;

    CTX' = setCTX * (op0 - CTX) + CTX;
    SP' = setSP * (op0 - (SP +incStack)) + (SP +incStack);
    PC' = setPC * (op0 - PC) + PC;

    // ROM constraint: call * setRR = 0
    RR' = setRR * (op0 - RR) + call * (zkPC + 1 - RR) + RR;
    GAS' = setGAS * (op0 - GAS) + GAS;

    pol decRCX = repeat * (1-RCXIsZero);
    RCX' = setRCX * (op0 - (RCX-decRCX)) + (RCX-decRCX);

    HASHPOS' = setHASHPOS * (op0 - HASHPOS) + HASHPOS + hashK * D0 + hashK1;

    pol doJMP = JMPN*isNeg + JMP + JMPC*carry + JMPZ*op0IsZero + return + call;
    pol elseJMP = JMPN*(1-isNeg) + JMPC*(1-carry) + JMPZ*(1-op0IsZero);

    pol commit jmpAddr;
    pol commit elseAddr;
    pol commit useJmpAddr;
    pol commit useElseAddr;

    // ROM/Zkasm constraint: useJmpAddr * return = 0
    pol finalJmpAddr = useJmpAddr * (jmpAddr - addr ) + return * (RR - addr) + addr;
    pol nextNoJmpZkPC = zkPC + 1 - ((1-RCXIsZero)*repeat);
    pol finalElseAddr = useElseAddr * (elseAddr - nextNoJmpZkPC) + nextNoJmpZkPC;

    // if elseAddr wasn't specified on zkasm, compiler put current address + 1
    zkPC' = doJMP * (finalJmpAddr - nextNoJmpZkPC) + elseJMP * (finalElseAddr - nextNoJmpZkPC) + nextNoJmpZkPC;

    zkPC * Global.L1 = 0;

    (A0-op0)*assert = 0;
    (A1-op1)*assert = 0;

    public oldStateRoot0 = FREE0(2);
    public oldStateRoot1 = FREE1(2);
    public oldStateRoot2 = FREE0(3);
    public oldStateRoot3 = FREE1(3);
    public oldStateRoot4 = FREE0(4);
    public oldStateRoot5 = FREE1(4);
    public oldStateRoot6 = FREE0(5);
    public oldStateRoot7 = FREE1(5);
    Global.L4' * (FREE0 - :oldStateRoot0) = 0;
    Global.L4' * (FREE1 - :oldStateRoot1) = 0;
    Global.L4  * (FREE0 - :oldStateRoot2) = 0;
    Global.L4  * (FREE1 - :oldStateRoot3) = 0;
    Global.L6' * (FREE0 - :oldStateRoot4) = 0;
    Global.L6' * (FREE1 - :oldStateRoot5) = 0;
    Global.L6  * (FREE0 - :oldStateRoot6) = 0;
    Global.L6  * (FREE1 - :oldStateRoot7) = 0;

    public oldAccInputHash0 = FREE0(6);
    public oldAccInputHash1 = FREE1(6);
    public oldAccInputHash2 = FREE0(7);
    public oldAccInputHash3 = FREE1(7);
    public oldAccInputHash4 = FREE0(8);
    public oldAccInputHash5 = FREE1(8);
    public oldAccInputHash6 = FREE0(9);
    public oldAccInputHash7 = FREE1(9);
    Global.L8'  * (FREE0 - :oldAccInputHash0) = 0;
    Global.L8'  * (FREE1 - :oldAccInputHash1) = 0;
    Global.L8   * (FREE0 - :oldAccInputHash2) = 0;
    Global.L8   * (FREE1 - :oldAccInputHash3) = 0;
    Global.L10' * (FREE0 - :oldAccInputHash4) = 0;
    Global.L10' * (FREE1 - :oldAccInputHash5) = 0;
    Global.L10  * (FREE0 - :oldAccInputHash6) = 0;
    Global.L10  * (FREE1 - :oldAccInputHash7) = 0;

    public oldBatchNum = SP(0);
    Global.L1 * (SP - :oldBatchNum) = 0;

    public chainId = GAS(0);
    Global.L1 * (GAS - :chainId) = 0;

    public forkId = CTX(0);
    Global.L1 * (CTX - :forkId) = 0;

    public newStateRoot0 = FREE0(%N-12);
    public newStateRoot1 = FREE1(%N-12);
    public newStateRoot2 = FREE0(%N-11);
    public newStateRoot3 = FREE1(%N-11);
    public newStateRoot4 = FREE0(%N-10);
    public newStateRoot5 = FREE1(%N-10);
    public newStateRoot6 = FREE0(%N-9);
    public newStateRoot7 = FREE1(%N-9);
    Global.LLAST11' * (FREE0 - :newStateRoot0) = 0;
    Global.LLAST11' * (FREE1 - :newStateRoot1) = 0;
    Global.LLAST11  * (FREE0 - :newStateRoot2) = 0;
    Global.LLAST11  * (FREE1 - :newStateRoot3) = 0;
    Global.LLAST9'  * (FREE0 - :newStateRoot4) = 0;
    Global.LLAST9'  * (FREE1 - :newStateRoot5) = 0;
    Global.LLAST9   * (FREE0 - :newStateRoot6) = 0;
    Global.LLAST9   * (FREE1 - :newStateRoot7) = 0;

    public newAccInputHash0 = FREE0(%N-8);
    public newAccInputHash1 = FREE1(%N-8);
    public newAccInputHash2 = FREE0(%N-7);
    public newAccInputHash3 = FREE1(%N-7);
    public newAccInputHash4 = FREE0(%N-6);
    public newAccInputHash5 = FREE1(%N-6);
    public newAccInputHash6 = FREE0(%N-5);
    public newAccInputHash7 = FREE1(%N-5);
    Global.LLAST7' * (FREE0 - :newAccInputHash0) = 0;
    Global.LLAST7' * (FREE1 - :newAccInputHash1) = 0;
    Global.LLAST7  * (FREE0 - :newAccInputHash2) = 0;
    Global.LLAST7  * (FREE1 - :newAccInputHash3) = 0;
    Global.LLAST5' * (FREE0 - :newAccInputHash4) = 0;
    Global.LLAST5' * (FREE1 - :newAccInputHash5) = 0;
    Global.LLAST5  * (FREE0 - :newAccInputHash6) = 0;
    Global.LLAST5  * (FREE1 - :newAccInputHash7) = 0;

    public localExitRoot0 = FREE0(%N-4);
    public localExitRoot1 = FREE1(%N-4);
    public localExitRoot2 = FREE0(%N-3);
    public localExitRoot3 = FREE1(%N-3);
    public localExitRoot4 = FREE0(%N-2);
    public localExitRoot5 = FREE1(%N-2);
    public localExitRoot6 = FREE0(%N-1);
    public localExitRoot7 = FREE1(%N-1);
    Global.LLAST3' * (FREE0 - :localExitRoot0) = 0;
    Global.LLAST3' * (FREE1 - :localExitRoot1) = 0;
    Global.LLAST3  * (FREE0 - :localExitRoot2) = 0;
    Global.LLAST3  * (FREE1 - :localExitRoot3) = 0;
    Global.LLAST'  * (FREE0 - :localExitRoot4) = 0;
    Global.LLAST'  * (FREE1 - :localExitRoot5) = 0;
    Global.LLAST   * (FREE0 - :localExitRoot6) = 0;
    Global.LLAST   * (FREE1 - :localExitRoot7) = 0;

    public newBatchNum = PC(%N-1);
    Global.LLAST * (PC - :newBatchNum) = 0;

/////////
// ROM Plookpups
/////////

    /*
       code generated with:
       node tools/pil_pol_table/bits_compose.js "arith,assert,bin,hashK,hashKDigest,hashKLen,ind,indRR,isMem,isStack,JMP,JMPC,JMPN,memAlignRD,memAlignWR,memAlignWR8,mOp,mWR,repeat,setA,setB,setC,setCTX,setD,setE,setGAS,setHASHPOS,setPC,setRCX,setRR,setSP,useCTX,useJmpAddr,JMPZ,call,return,hashK1,useElseAddr" -b
    */

    pol operations =
                  2**0 * arith         + 2**1  * assert        + 2**2  * bin            + 2**3  * hashK
                + 2**4  * hashKDigest   + 2**5  * hashKLen      + 2**6  * ind           + 2**7  * indRR
                + 2**8  * isMem         + 2**9  * isStack       + 2**10 * JMP           + 2**11 * JMPC
                + 2**12 * JMPN          + 2**13 * memAlignRD    + 2**14 * memAlignWR    + 2**15 * memAlignWR8
                + 2**16 * mOp           + 2**17 * mWR           + 2**18 * repeat        + 2**19 * setA
                + 2**20 * setB          + 2**21 * setC          + 2**22 * setCTX        + 2**23 * setD
                + 2**24 * setE          + 2**25 * setGAS        + 2**26 * setHASHPOS    + 2**27 * setPC
                + 2**28 * setRCX        + 2**29 * setRR         + 2**30 * setSP         + 2**31 * useCTX
                + 2**32 * useJmpAddr    + 2**33 * JMPZ          + 2**34 * call          + 2**35 * return
                + 2**36 * hashK1        + 2**37 * useElseAddr;

    (1 - arith) * arith = 0;
    (1 - assert) * assert = 0;
    (1 - bin) * bin = 0;
    (1 - hashK) * hashK = 0;
    (1 - hashKDigest) * hashKDigest = 0;
    (1 - hashKLen) * hashKLen = 0;
    (1 - ind) * ind = 0;
    (1 - indRR) * indRR = 0;
    (1 - isMem) * isMem = 0;
    (1 - isStack) * isStack = 0;
    (1 - JMP) * JMP = 0;
    (1 - JMPC) * JMPC = 0;
    (1 - JMPN) * JMPN = 0;
    (1 - memAlignRD) * memAlignRD = 0;
    (1 - memAlignWR) * memAlignWR = 0;
    (1 - memAlignWR8) * memAlignWR8 = 0;
    (1 - mOp) * mOp = 0;
    (1 - mWR) * mWR = 0;
    (1 - repeat) * repeat = 0;
    (1 - setA) * setA = 0;
    (1 - setB) * setB = 0;
    (1 - setC) * setC = 0;
    (1 - setCTX) * setCTX = 0;
    (1 - setD) * setD = 0;
    (1 - setE) * setE = 0;
    (1 - setGAS) * setGAS = 0;
    (1 - setHASHPOS) * setHASHPOS = 0;
    (1 - setPC) * setPC = 0;
    (1 - setRCX) * setRCX = 0;
    (1 - setRR) * setRR = 0;
    (1 - setSP) * setSP = 0;
    (1 - useCTX) * useCTX = 0;
    (1 - useJmpAddr) * useJmpAddr = 0;
    (1 - JMPZ) * JMPZ = 0;
    (1 - call) * call = 0;
    (1 - return) * return = 0;
    (1 - hashK1) * hashK1 = 0;
    (1 - useElseAddr) * useElseAddr = 0;


    {
        CONST0, CONST1,
        inA, inB, inC, inROTL_C, inD, inE, inFREE,
        inCTX, inSP, inPC, inGAS, inHASHPOS, inSTEP, inRR, inRCX,
        inCntArith, inCntBinary, inCntKeccakF, inCntMemAlign,
        operations, offset, incStack, binOpcode, jmpAddr, elseAddr, zkPC
    } in {
        Rom.CONST0, Rom.CONST1,
        Rom.inA, Rom.inB, Rom.inC, Rom.inROTL_C, Rom.inD, Rom.inE, Rom.inFREE,
        Rom.inCTX, Rom.inSP, Rom.inPC, Rom.inGAS, Rom.inHASHPOS, Rom.inSTEP, Rom.inRR, Rom.inRCX,
        Rom.inCntArith, Rom.inCntBinary, Rom.inCntKeccakF, Rom.inCntMemAlign,
        Rom.operations, Rom.offset, Rom.incStack, Rom.binOpcode, Rom.jmpAddr, Rom.elseAddr, Rom.line
    };

/////////
// Arithmetic Plookpups
/////////

    arith {  A0, A1,
        B0, B1,
        C0, C1,
        D0, D1,
        op0, op1 } is
    Global.CLK8[7] {
        Arith.a[0] + Arith.a[1]*2**16, Arith.a[2] + Arith.a[3]*2**16,
        Arith.b[0] + Arith.b[1]*2**16, Arith.b[2] + Arith.b[3]*2**16,
        Arith.c[0] + Arith.c[1]*2**16, Arith.c[2] + Arith.c[3]*2**16,
        Arith.d[0] + Arith.d[1]*2**16, Arith.d[2] + Arith.d[3]*2**16,
        Arith.op[0] + Arith.op[1]*2**16, Arith.op[2] + Arith.op[3]*2**16
    };

    cntArith' = cntArith*(1-Global.L1) + arith;

/////////
// Binary Plookpups
/////////

    bin {
        binOpcode,
        A0, A1,
        B0, B1,
        op0, op1,
        carry
    } is
    Binary.resultBinOp {
        Binary.lOpcode,
        Binary.a[0], Binary.a[1],
        Binary.b[0], Binary.b[1],
        Binary.c[0], Binary.c[1],
        Binary.lCout
    };

    cntBinary' = cntBinary*(1-Global.L1) + bin;

/////////
// HASHK Plookpups
/////////
    hashK + hashK1 {
        addr,
        HASHPOS,
        D0 * hashK + hashK1,
        op0, op1
    } in
    PaddingKK.crLatch * PaddingKK.r8valid {
        PaddingKK.addr,
        PaddingKK.len - PaddingKK.rem - PaddingKK.crLen + 1,
        PaddingKK.crLen,
        PaddingKK.crV0C, PaddingKK.crV1C
    };

    hashKLen {
        addr,
        op0
    } is
    PaddingKK.lastHashLen {
        PaddingKK.addr,
        PaddingKK.len
    };

    hashKDigest {
        addr,
        op0, op1, A0, A1,
        B0, B1, C0, C1,
        incCounter
    } is
    PaddingKK.lastHashDigest {
        PaddingKK.addr,
        PaddingKK.hash0, PaddingKK.hash1, PaddingKK.hash2, PaddingKK.hash3,
        PaddingKK.hash4, PaddingKK.hash5, PaddingKK.hash6, PaddingKK.hash7,
        PaddingKK.incCounter
    };

    cntKeccakF' = cntKeccakF*(1-Global.L1) + incCounter*hashKDigest;

/////////
// Mem Plookpups
/////////
    mOp {
        addr,
        Global.STEP,
        mWR,
        op0, op1
    } is
    Mem.mOp {
        Mem.addr,
        Mem.step,
        Mem.mWr,
        Mem.val[0], Mem.val[1]
    };

/////////
// MemAlign Plookpups
/////////

    // memAlign RD
    memAlignRD {
        0, 0,
        A0, A1,
        B0, B1,
        op0, op1,
        C0
    } is
    MemAlign.resultRd {
        MemAlign.wr64,
        MemAlign.wr8,
        MemAlign.m0[0], MemAlign.m0[1],
        MemAlign.m1[0], MemAlign.m1[1],
        MemAlign.v[0], MemAlign.v[1],
        MemAlign.offset
    };

    memAlignWR {
        1, 0,
        A0, A1,
        B0, B1,
        op0, op1,
        C0,
        D0, D1,
        E0, E1
    } is
    MemAlign.resultWr64 {
        MemAlign.wr64,
        MemAlign.wr8,
        MemAlign.m0[0], MemAlign.m0[1],
        MemAlign.m1[0], MemAlign.m1[1],
        MemAlign.v[0], MemAlign.v[1],
        MemAlign.offset,
        MemAlign.w0[0], MemAlign.w0[1],
        MemAlign.w1[0], MemAlign.w1[1]
    };

    memAlignWR8 {
        0, 1,
        A0, A1,
        op0, op1,
        C0,
        D0, D1
    } is
    MemAlign.resultWr8 {
        MemAlign.wr64,
        MemAlign.wr8,
        MemAlign.m0[0], MemAlign.m0[1],
        MemAlign.v[0], MemAlign.v[1],
        MemAlign.offset,
        MemAlign.w0[0], MemAlign.w0[1]
    };

    cntMemAlign' = cntMemAlign*(1-Global.L1) + memAlignRD + memAlignWR + memAlignWR8;

